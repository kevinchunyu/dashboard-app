{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../src/utils/helpers.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;;AAElC;;;GAGG;AACH,MAAM,UAAU,eAAe,CAAC,KAAyB;IACvD,kCAAkC;IAClC,oDAAoD;IACpD,4CAA4C;IAC5C,OAAO,KAAK,aAAL,KAAK,uBAAL,KAAK,CAAE,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;AAClD,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,QAAQ,CAAC,WAAmB;IAC1C,OAAO,WAAW,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;AACnC,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,eAAe,CACnC,MAA6B,EAC7B,SAAkB;IAElB,MAAM,OAAO,GAAa,EAAE,CAAC;IAC7B,IAAI,SAAS,GAAG,CAAC,CAAC;IAElB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;QACrC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE;YAC1B,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACpB,SAAS,IAAI,KAAK,CAAC,MAAM,CAAC;YAE1B,IAAI,SAAS,IAAI,SAAS,GAAG,SAAS,EAAE;gBACtC,MAAM,CAAC,IAAI,KAAK,CAAC,6CAA6C,SAAS,SAAS,CAAC,CAAC,CAAC;aACpF;QACH,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACxD,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;IAC3C,CAAC,CAAC,CAAC;AACL,CAAC;AAED,MAAM,UAAiB,oBAAoB,CACzC,MAA6B,EAC7B,SAAiB;;;QAEjB,IAAI,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;QACpC,IAAI,WAAW,GAAG,CAAC,CAAC;;YAEpB,KAAyB,eAAA,WAAA,cAAA,MAAM,CAAA,YAAA;gBAAN,sBAAM;gBAAN,WAAM;;oBAApB,MAAM,IAAI,KAAA,CAAA;oBACnB,MAAM,YAAY,GAAG,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;oBAC9E,IAAI,UAAU,GAAG,CAAC,CAAC;oBAEnB,OAAO,UAAU,GAAG,YAAY,CAAC,MAAM,EAAE;wBACvC,MAAM,WAAW,GAAG,YAAY,CAAC,IAAI,CAAC,KAAK,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;wBACtE,UAAU,IAAI,WAAW,CAAC;wBAC1B,WAAW,IAAI,WAAW,CAAC;wBAC3B,IAAI,WAAW,IAAI,SAAS,EAAE;4BAC5B,oBAAM,KAAK,CAAA,CAAC;4BACZ,WAAW,GAAG,CAAC,CAAC;4BAChB,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;yBACjC;qBACF;;;;;aACF;;;;;;;;;QAED,IAAI,WAAW,GAAG,CAAC,EAAE;YACnB,oBAAM,KAAK,CAAC,QAAQ,CAAC,CAAC,EAAE,WAAW,CAAC,CAAA,CAAC;SACtC;IACH,CAAC;CAAA","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Extract the path part from the next link value returned by the service,\n * @internal\n */\nexport function extractNextLink(value: string | undefined): string | undefined {\n  // The link value has this pattern\n  //     `</acr/v1/name/...&n=2&orderby=>; rel=\"next\"`\n  // and we only want the part inside of <...>\n  return value?.substr(1, value.indexOf(\">\") - 1);\n}\n\n/**\n * Checks whether a string is a digest\n * @internal\n */\nexport function isDigest(tagOrDigest: string): boolean {\n  return tagOrDigest.includes(\":\");\n}\n\nexport async function readStreamToEnd(\n  stream: NodeJS.ReadableStream,\n  maxLength?: number\n): Promise<Buffer> {\n  const buffers: Buffer[] = [];\n  let bytesRead = 0;\n\n  return new Promise((resolve, reject) => {\n    stream.on(\"data\", (chunk) => {\n      buffers.push(chunk);\n      bytesRead += chunk.length;\n\n      if (maxLength && bytesRead > maxLength) {\n        reject(new Error(`Stream exceeded maximum allowed length of ${maxLength} bytes.`));\n      }\n    });\n    stream.on(\"end\", () => resolve(Buffer.concat(buffers)));\n    stream.on(\"error\", (err) => reject(err));\n  });\n}\n\nexport async function* readChunksFromStream(\n  stream: NodeJS.ReadableStream,\n  chunkSize: number\n): AsyncGenerator<Buffer> {\n  let chunk = Buffer.alloc(chunkSize);\n  let chunkCursor = 0;\n\n  for await (const data of stream) {\n    const dataAsBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, \"utf8\");\n    let dataCursor = 0;\n\n    while (dataCursor < dataAsBuffer.length) {\n      const bytesCopied = dataAsBuffer.copy(chunk, chunkCursor, dataCursor);\n      dataCursor += bytesCopied;\n      chunkCursor += bytesCopied;\n      if (chunkCursor >= chunkSize) {\n        yield chunk;\n        chunkCursor = 0;\n        chunk = Buffer.alloc(chunkSize);\n      }\n    }\n  }\n\n  if (chunkCursor > 0) {\n    yield chunk.subarray(0, chunkCursor);\n  }\n}\n"]}