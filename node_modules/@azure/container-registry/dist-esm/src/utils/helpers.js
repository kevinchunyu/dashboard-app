// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncGenerator, __asyncValues, __await } from "tslib";
/**
 * Extract the path part from the next link value returned by the service,
 * @internal
 */
export function extractNextLink(value) {
    // The link value has this pattern
    //     `</acr/v1/name/...&n=2&orderby=>; rel="next"`
    // and we only want the part inside of <...>
    return value === null || value === void 0 ? void 0 : value.substr(1, value.indexOf(">") - 1);
}
/**
 * Checks whether a string is a digest
 * @internal
 */
export function isDigest(tagOrDigest) {
    return tagOrDigest.includes(":");
}
export async function readStreamToEnd(stream, maxLength) {
    const buffers = [];
    let bytesRead = 0;
    return new Promise((resolve, reject) => {
        stream.on("data", (chunk) => {
            buffers.push(chunk);
            bytesRead += chunk.length;
            if (maxLength && bytesRead > maxLength) {
                reject(new Error(`Stream exceeded maximum allowed length of ${maxLength} bytes.`));
            }
        });
        stream.on("end", () => resolve(Buffer.concat(buffers)));
        stream.on("error", (err) => reject(err));
    });
}
export function readChunksFromStream(stream, chunkSize) {
    return __asyncGenerator(this, arguments, function* readChunksFromStream_1() {
        var _a, e_1, _b, _c;
        let chunk = Buffer.alloc(chunkSize);
        let chunkCursor = 0;
        try {
            for (var _d = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a = stream_1_1.done, !_a;) {
                _c = stream_1_1.value;
                _d = false;
                try {
                    const data = _c;
                    const dataAsBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, "utf8");
                    let dataCursor = 0;
                    while (dataCursor < dataAsBuffer.length) {
                        const bytesCopied = dataAsBuffer.copy(chunk, chunkCursor, dataCursor);
                        dataCursor += bytesCopied;
                        chunkCursor += bytesCopied;
                        if (chunkCursor >= chunkSize) {
                            yield yield __await(chunk);
                            chunkCursor = 0;
                            chunk = Buffer.alloc(chunkSize);
                        }
                    }
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = stream_1.return)) yield __await(_b.call(stream_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (chunkCursor > 0) {
            yield yield __await(chunk.subarray(0, chunkCursor));
        }
    });
}
//# sourceMappingURL=helpers.js.map