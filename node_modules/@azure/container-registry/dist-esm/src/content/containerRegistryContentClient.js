// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues } from "tslib";
import { bearerTokenAuthenticationPolicy, RestError, } from "@azure/core-rest-pipeline";
import { GeneratedClient } from "../generated";
import { ChallengeHandler } from "../containerRegistryChallengeHandler";
import { ContainerRegistryRefreshTokenCredential } from "../containerRegistryTokenCredential";
import { logger } from "../logger";
import { calculateDigest } from "../utils/digest";
import { KnownManifestMediaType, } from "./models";
import { isDigest, readChunksFromStream, readStreamToEnd } from "../utils/helpers";
import { Readable } from "stream";
import { tracingClient } from "../tracing";
import crypto from "crypto";
import { RetriableReadableStream } from "../utils/retriableReadableStream";
const LATEST_API_VERSION = "2021-07-01";
const CHUNK_SIZE = 4 * 1024 * 1024; // 4 MB
const MAX_MANIFEST_SIZE_BYTES = 4 * 1024 * 1024; // 4 MB
const ACCEPTED_MANIFEST_MEDIA_TYPES = [
    KnownManifestMediaType.OciImageManifest,
    KnownManifestMediaType.DockerManifest,
    "application/vnd.oci.image.index.v1+json",
    "application/vnd.docker.distribution.manifest.list.v2+json",
    "application/vnd.docker.container.image.v1+json",
];
function isReadableStream(body) {
    return body && typeof body.pipe === "function";
}
function assertHasProperty(obj, property) {
    if (!Object.prototype.hasOwnProperty.call(obj, property)) {
        throw new RestError(`Expected property ${String(property)} to be defined.`);
    }
}
/**
 * Error thrown when the Docker content digest returned from the
 * server does not match the digest calculated from the content.
 */
export class DigestMismatchError extends Error {
    constructor(message) {
        super(message);
        this.name = "DigestMismatchError";
    }
}
/**
 * The Azure Container Registry blob client, responsible for uploading and downloading blobs and manifests, the building blocks of artifacts.
 */
export class ContainerRegistryContentClient {
    /**
     * Creates an instance of a ContainerRegistryContentClient for managing container images and artifacts.
     *
     * Example usage:
     * ```ts
     * import { ContainerRegistryContentClient } from "@azure/container-registry";
     * import { DefaultAzureCredential} from "@azure/identity";
     *
     * const client = new ContainerRegistryContentClient(
     *    "<container registry API endpoint>",
     *    "<repository name>",
     *    new DefaultAzureCredential()
     * );
     * ```
     * @param endpoint - the URL endpoint of the container registry
     * @param repositoryName - the name of the repository that logically groups the artifact parts
     * @param credential - used to authenticate requests to the service
     * @param options - optional configuration used to send requests to the service
     */
    constructor(endpoint, repositoryName, credential, options = {}) {
        var _a, _b;
        if (!endpoint) {
            throw new Error("invalid endpoint");
        }
        this.endpoint = endpoint;
        this.repositoryName = repositoryName;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), { loggingOptions: {
                logger: logger.info,
                // This array contains header names we want to log that are not already
                // included as safe. Unknown/unsafe headers are logged as "<REDACTED>".
                additionalAllowedQueryParameters: [
                    "last",
                    "n",
                    "orderby",
                    "digest",
                    "_nouploadcache",
                    "_state",
                ],
            } });
        const defaultScope = `${(_a = options.audience) !== null && _a !== void 0 ? _a : "https://containerregistry.azure.net"}/.default`;
        const serviceVersion = (_b = options.serviceVersion) !== null && _b !== void 0 ? _b : LATEST_API_VERSION;
        const authClient = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client.pipeline.addPolicy(bearerTokenAuthenticationPolicy({
            credential,
            scopes: [defaultScope],
            challengeCallbacks: new ChallengeHandler(new ContainerRegistryRefreshTokenCredential(authClient, defaultScope, credential)),
        }));
    }
    /**
     * Delete a blob.
     * @param digest - the digest of the blob to delete
     * @param options - optional configuration used to send requests to the service
     */
    async deleteBlob(digest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.deleteBlob", options, async (updatedOptions) => {
            await this.client.containerRegistryBlob.deleteBlob(this.repositoryName, digest, updatedOptions);
        });
    }
    /**
     * Upload a manifest for an OCI artifact.
     *
     * @param manifest - the manifest to upload.
     */
    async setManifest(manifest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.uploadManifest", options, async (updatedOptions) => {
            var _a;
            let manifestBody;
            let tagOrDigest = options === null || options === void 0 ? void 0 : options.tag;
            if (Buffer.isBuffer(manifest)) {
                manifestBody = manifest;
                tagOrDigest !== null && tagOrDigest !== void 0 ? tagOrDigest : (tagOrDigest = await calculateDigest(manifest));
            }
            else if (isReadableStream(manifest)) {
                manifestBody = await readStreamToEnd(manifest);
                tagOrDigest !== null && tagOrDigest !== void 0 ? tagOrDigest : (tagOrDigest = await calculateDigest(manifestBody));
            }
            else {
                manifestBody = Buffer.from(JSON.stringify(manifest));
                tagOrDigest !== null && tagOrDigest !== void 0 ? tagOrDigest : (tagOrDigest = await calculateDigest(manifestBody));
            }
            const createManifestResult = await this.client.containerRegistry.createManifest(this.repositoryName, tagOrDigest, manifestBody, Object.assign({ contentType: (_a = options === null || options === void 0 ? void 0 : options.mediaType) !== null && _a !== void 0 ? _a : KnownManifestMediaType.OciImageManifest }, updatedOptions));
            assertHasProperty(createManifestResult, "dockerContentDigest");
            return { digest: createManifestResult.dockerContentDigest };
        });
    }
    /**
     * Downloads the manifest for an OCI artifact.
     *
     * @param tagOrDigest - a tag or digest that identifies the artifact
     * @returns - the downloaded manifest.
     */
    async getManifest(tagOrDigest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.downloadManifest", options, async (updatedOptions) => {
            const response = await this.client.containerRegistry.getManifest(this.repositoryName, tagOrDigest, Object.assign({ accept: ACCEPTED_MANIFEST_MEDIA_TYPES.join(", ") }, updatedOptions));
            assertHasProperty(response, "mediaType");
            const content = response.readableStreamBody
                ? await readStreamToEnd(response.readableStreamBody, MAX_MANIFEST_SIZE_BYTES)
                : Buffer.alloc(0);
            const expectedDigest = await calculateDigest(content);
            if (isDigest(tagOrDigest) && expectedDigest !== tagOrDigest) {
                throw new DigestMismatchError("Digest of downloaded manifest does not match the input digest");
            }
            if (response.dockerContentDigest !== expectedDigest) {
                throw new DigestMismatchError("Computed digest of downloaded manifest does not match the value of the Docker-Content-Digest header");
            }
            return {
                digest: response.dockerContentDigest,
                mediaType: response.mediaType,
                content,
                manifest: JSON.parse(content.toString("utf-8")),
            };
        });
    }
    /**
     * Delete a manifest. Doing so effectively deletes an artifact from the registry.
     *
     * @param digest - the digest of the manifest to delete
     * @param options - optional configuration used to send requests to the service
     */
    async deleteManifest(digest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.deleteManifest", options, async (updatedOptions) => {
            await this.client.containerRegistry.deleteManifest(this.repositoryName, digest, updatedOptions);
        });
    }
    /**
     * Upload an artifact blob.
     *
     * @param blobStream - the stream containing the blob data.
     */
    async uploadBlob(blob, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.uploadBlob", options, async (updatedOptions) => {
            var _a, e_1, _b, _c;
            const blobStream = Buffer.isBuffer(blob) ? Readable.from(blob) : blob;
            const startUploadResult = await this.client.containerRegistryBlob.startUpload(this.repositoryName, updatedOptions);
            assertHasProperty(startUploadResult, "location");
            let location = startUploadResult.location.substring(1);
            const chunks = readChunksFromStream(blobStream, CHUNK_SIZE);
            const hash = crypto.createHash("sha256");
            let bytesUploaded = 0;
            try {
                for (var _d = true, chunks_1 = __asyncValues(chunks), chunks_1_1; chunks_1_1 = await chunks_1.next(), _a = chunks_1_1.done, !_a;) {
                    _c = chunks_1_1.value;
                    _d = false;
                    try {
                        const chunk = _c;
                        hash.write(chunk);
                        const result = await this.client.containerRegistryBlob.uploadChunk(location, chunk, updatedOptions);
                        bytesUploaded += chunk.byteLength;
                        assertHasProperty(result, "location");
                        location = result.location.substring(1);
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = chunks_1.return)) await _b.call(chunks_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            hash.end();
            const digest = `sha256:${hash.digest("hex")}`;
            const { dockerContentDigest: digestFromResponse } = await this.client.containerRegistryBlob.completeUpload(digest, location, updatedOptions);
            if (digest !== digestFromResponse) {
                throw new DigestMismatchError("Digest of blob to upload does not match the digest from the server.");
            }
            return { digest, sizeInBytes: bytesUploaded };
        });
    }
    /**
     * Download a blob that is part of an artifact.
     *
     * @param digest - the digest of the blob to download
     * @param options - optional configuration used to send requests to the service
     * @returns - the downloaded blob
     */
    async downloadBlob(digest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.downloadBlob", options, async (updatedOptions) => {
            const initialResponse = await this.client.containerRegistryBlob.getBlob(this.repositoryName, digest, updatedOptions);
            assertHasProperty(initialResponse, "readableStreamBody");
            assertHasProperty(initialResponse, "contentLength");
            const hash = crypto.createHash("sha256");
            return {
                digest,
                content: new RetriableReadableStream(initialResponse.readableStreamBody, async (pos) => {
                    const retryResponse = await this.client.containerRegistryBlob.getChunk(this.repositoryName, digest, `${pos}-`, updatedOptions);
                    assertHasProperty(retryResponse, "readableStreamBody");
                    return retryResponse.readableStreamBody;
                }, 0, initialResponse.contentLength, {
                    onData: (data) => hash.write(data),
                    onEnd: () => {
                        hash.end();
                        const calculatedDigest = `sha256:${hash.digest("hex")}`;
                        if (digest !== calculatedDigest) {
                            throw new DigestMismatchError("Digest calculated from downloaded blob content does not match digest requested.");
                        }
                    },
                }),
            };
        });
    }
}
//# sourceMappingURL=containerRegistryContentClient.js.map