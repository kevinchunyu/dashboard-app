{"version":3,"file":"containerRegistryContentClient.js","sourceRoot":"","sources":["../../../src/content/containerRegistryContentClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  InternalPipelineOptions,\n  bearerTokenAuthenticationPolicy,\n  RestError,\n} from \"@azure/core-rest-pipeline\";\nimport { TokenCredential } from \"@azure/core-auth\";\nimport { GeneratedClient } from \"../generated\";\nimport { ChallengeHandler } from \"../containerRegistryChallengeHandler\";\nimport { ContainerRegistryRefreshTokenCredential } from \"../containerRegistryTokenCredential\";\nimport { logger } from \"../logger\";\nimport { calculateDigest } from \"../utils/digest\";\nimport {\n  DeleteBlobOptions,\n  DeleteManifestOptions,\n  DownloadBlobOptions,\n  DownloadBlobResult,\n  GetManifestOptions,\n  GetManifestResult,\n  KnownManifestMediaType,\n  UploadBlobOptions,\n  UploadBlobResult,\n  SetManifestOptions,\n  SetManifestResult,\n  OciImageManifest,\n} from \"./models\";\nimport { CommonClientOptions } from \"@azure/core-client\";\nimport { isDigest, readChunksFromStream, readStreamToEnd } from \"../utils/helpers\";\nimport { Readable } from \"stream\";\nimport { tracingClient } from \"../tracing\";\nimport crypto from \"crypto\";\nimport { RetriableReadableStream } from \"../utils/retriableReadableStream\";\n\nconst LATEST_API_VERSION = \"2021-07-01\";\n\nconst CHUNK_SIZE = 4 * 1024 * 1024; // 4 MB\nconst MAX_MANIFEST_SIZE_BYTES = 4 * 1024 * 1024; // 4 MB\n\nconst ACCEPTED_MANIFEST_MEDIA_TYPES = [\n  KnownManifestMediaType.OciImageManifest,\n  KnownManifestMediaType.DockerManifest,\n  \"application/vnd.oci.image.index.v1+json\",\n  \"application/vnd.docker.distribution.manifest.list.v2+json\",\n  \"application/vnd.docker.container.image.v1+json\",\n];\n\nfunction isReadableStream(body: any): body is NodeJS.ReadableStream {\n  return body && typeof body.pipe === \"function\";\n}\n\nfunction assertHasProperty<T, U extends keyof T>(\n  obj: T,\n  property: U\n): asserts obj is T & Required<Pick<T, U>> {\n  if (!Object.prototype.hasOwnProperty.call(obj, property)) {\n    throw new RestError(`Expected property ${String(property)} to be defined.`);\n  }\n}\n\n/**\n * Error thrown when the Docker content digest returned from the\n * server does not match the digest calculated from the content.\n */\nexport class DigestMismatchError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"DigestMismatchError\";\n  }\n}\n\n/**\n * Client options used to configure Container Registry Blob API requests.\n */\nexport interface ContainerRegistryContentClientOptions extends CommonClientOptions {\n  /**\n   * Gets or sets the audience to use for authentication with Azure Active Directory.\n   * The authentication scope will be set from this audience.\n   * See {@link KnownContainerRegistryAudience} for known audience values.\n   */\n  audience?: string;\n  /**\n   * The version of service API to make calls against.\n   */\n  serviceVersion?: \"2021-07-01\";\n}\n\n/**\n * The Azure Container Registry blob client, responsible for uploading and downloading blobs and manifests, the building blocks of artifacts.\n */\nexport class ContainerRegistryContentClient {\n  /**\n   * The Azure Container Registry endpoint.\n   */\n  public readonly endpoint: string;\n\n  /**\n   * The name of the repository that logically groups the artifact parts.\n   */\n  public readonly repositoryName: string;\n\n  private client: GeneratedClient;\n\n  /**\n   * Creates an instance of a ContainerRegistryContentClient for managing container images and artifacts.\n   *\n   * Example usage:\n   * ```ts\n   * import { ContainerRegistryContentClient } from \"@azure/container-registry\";\n   * import { DefaultAzureCredential} from \"@azure/identity\";\n   *\n   * const client = new ContainerRegistryContentClient(\n   *    \"<container registry API endpoint>\",\n   *    \"<repository name>\",\n   *    new DefaultAzureCredential()\n   * );\n   * ```\n   * @param endpoint - the URL endpoint of the container registry\n   * @param repositoryName - the name of the repository that logically groups the artifact parts\n   * @param credential - used to authenticate requests to the service\n   * @param options - optional configuration used to send requests to the service\n   */\n  constructor(\n    endpoint: string,\n    repositoryName: string,\n    credential: TokenCredential,\n    options: ContainerRegistryContentClientOptions = {}\n  ) {\n    if (!endpoint) {\n      throw new Error(\"invalid endpoint\");\n    }\n\n    this.endpoint = endpoint;\n    this.repositoryName = repositoryName;\n\n    const internalPipelineOptions: InternalPipelineOptions = {\n      ...options,\n      loggingOptions: {\n        logger: logger.info,\n        // This array contains header names we want to log that are not already\n        // included as safe. Unknown/unsafe headers are logged as \"<REDACTED>\".\n        additionalAllowedQueryParameters: [\n          \"last\",\n          \"n\",\n          \"orderby\",\n          \"digest\",\n          \"_nouploadcache\",\n          \"_state\",\n        ],\n      },\n    };\n\n    const defaultScope = `${options.audience ?? \"https://containerregistry.azure.net\"}/.default`;\n    const serviceVersion = options.serviceVersion ?? LATEST_API_VERSION;\n    const authClient = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);\n    this.client = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);\n    this.client.pipeline.addPolicy(\n      bearerTokenAuthenticationPolicy({\n        credential,\n        scopes: [defaultScope],\n        challengeCallbacks: new ChallengeHandler(\n          new ContainerRegistryRefreshTokenCredential(authClient, defaultScope, credential)\n        ),\n      })\n    );\n  }\n\n  /**\n   * Delete a blob.\n   * @param digest - the digest of the blob to delete\n   * @param options - optional configuration used to send requests to the service\n   */\n  public async deleteBlob(digest: string, options: DeleteBlobOptions = {}): Promise<void> {\n    return tracingClient.withSpan(\n      \"ContainerRegistryContentClient.deleteBlob\",\n      options,\n      async (updatedOptions) => {\n        await this.client.containerRegistryBlob.deleteBlob(\n          this.repositoryName,\n          digest,\n          updatedOptions\n        );\n      }\n    );\n  }\n\n  /**\n   * Upload a manifest for an OCI artifact.\n   *\n   * @param manifest - the manifest to upload.\n   */\n  public async setManifest(\n    manifest: Buffer | NodeJS.ReadableStream | OciImageManifest | Record<string, unknown>,\n    options: SetManifestOptions = {}\n  ): Promise<SetManifestResult> {\n    return tracingClient.withSpan(\n      \"ContainerRegistryContentClient.uploadManifest\",\n      options,\n      async (updatedOptions) => {\n        let manifestBody: Buffer | (() => NodeJS.ReadableStream);\n        let tagOrDigest: string | undefined = options?.tag;\n\n        if (Buffer.isBuffer(manifest)) {\n          manifestBody = manifest;\n          tagOrDigest ??= await calculateDigest(manifest);\n        } else if (isReadableStream(manifest)) {\n          manifestBody = await readStreamToEnd(manifest);\n          tagOrDigest ??= await calculateDigest(manifestBody);\n        } else {\n          manifestBody = Buffer.from(JSON.stringify(manifest));\n          tagOrDigest ??= await calculateDigest(manifestBody);\n        }\n\n        const createManifestResult = await this.client.containerRegistry.createManifest(\n          this.repositoryName,\n          tagOrDigest,\n          manifestBody,\n          {\n            contentType: options?.mediaType ?? KnownManifestMediaType.OciImageManifest,\n            ...updatedOptions,\n          }\n        );\n\n        assertHasProperty(createManifestResult, \"dockerContentDigest\");\n\n        return { digest: createManifestResult.dockerContentDigest };\n      }\n    );\n  }\n\n  /**\n   * Downloads the manifest for an OCI artifact.\n   *\n   * @param tagOrDigest - a tag or digest that identifies the artifact\n   * @returns - the downloaded manifest.\n   */\n  public async getManifest(\n    tagOrDigest: string,\n    options: GetManifestOptions = {}\n  ): Promise<GetManifestResult> {\n    return tracingClient.withSpan(\n      \"ContainerRegistryContentClient.downloadManifest\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.containerRegistry.getManifest(\n          this.repositoryName,\n          tagOrDigest,\n          {\n            accept: ACCEPTED_MANIFEST_MEDIA_TYPES.join(\", \"),\n            ...updatedOptions,\n          }\n        );\n\n        assertHasProperty(response, \"mediaType\");\n\n        const content = response.readableStreamBody\n          ? await readStreamToEnd(response.readableStreamBody, MAX_MANIFEST_SIZE_BYTES)\n          : Buffer.alloc(0);\n\n        const expectedDigest = await calculateDigest(content);\n\n        if (isDigest(tagOrDigest) && expectedDigest !== tagOrDigest) {\n          throw new DigestMismatchError(\n            \"Digest of downloaded manifest does not match the input digest\"\n          );\n        }\n\n        if (response.dockerContentDigest !== expectedDigest) {\n          throw new DigestMismatchError(\n            \"Computed digest of downloaded manifest does not match the value of the Docker-Content-Digest header\"\n          );\n        }\n\n        return {\n          digest: response.dockerContentDigest,\n          mediaType: response.mediaType,\n          content,\n          manifest: JSON.parse(content.toString(\"utf-8\")),\n        };\n      }\n    );\n  }\n\n  /**\n   * Delete a manifest. Doing so effectively deletes an artifact from the registry.\n   *\n   * @param digest - the digest of the manifest to delete\n   * @param options - optional configuration used to send requests to the service\n   */\n  public async deleteManifest(digest: string, options: DeleteManifestOptions = {}): Promise<void> {\n    return tracingClient.withSpan(\n      \"ContainerRegistryContentClient.deleteManifest\",\n      options,\n      async (updatedOptions) => {\n        await this.client.containerRegistry.deleteManifest(\n          this.repositoryName,\n          digest,\n          updatedOptions\n        );\n      }\n    );\n  }\n\n  /**\n   * Upload an artifact blob.\n   *\n   * @param blobStream - the stream containing the blob data.\n   */\n  public async uploadBlob(\n    blob: NodeJS.ReadableStream | Buffer,\n    options: UploadBlobOptions = {}\n  ): Promise<UploadBlobResult> {\n    return tracingClient.withSpan(\n      \"ContainerRegistryContentClient.uploadBlob\",\n      options,\n      async (updatedOptions) => {\n        const blobStream = Buffer.isBuffer(blob) ? Readable.from(blob) : blob;\n\n        const startUploadResult = await this.client.containerRegistryBlob.startUpload(\n          this.repositoryName,\n          updatedOptions\n        );\n\n        assertHasProperty(startUploadResult, \"location\");\n        let location = startUploadResult.location.substring(1);\n\n        const chunks = readChunksFromStream(blobStream, CHUNK_SIZE);\n        const hash = crypto.createHash(\"sha256\");\n\n        let bytesUploaded = 0;\n\n        for await (const chunk of chunks) {\n          hash.write(chunk);\n          const result = await this.client.containerRegistryBlob.uploadChunk(\n            location,\n            chunk,\n            updatedOptions\n          );\n\n          bytesUploaded += chunk.byteLength;\n\n          assertHasProperty(result, \"location\");\n          location = result.location.substring(1);\n        }\n\n        hash.end();\n        const digest = `sha256:${hash.digest(\"hex\")}`;\n\n        const { dockerContentDigest: digestFromResponse } =\n          await this.client.containerRegistryBlob.completeUpload(digest, location, updatedOptions);\n\n        if (digest !== digestFromResponse) {\n          throw new DigestMismatchError(\n            \"Digest of blob to upload does not match the digest from the server.\"\n          );\n        }\n\n        return { digest, sizeInBytes: bytesUploaded };\n      }\n    );\n  }\n\n  /**\n   * Download a blob that is part of an artifact.\n   *\n   * @param digest - the digest of the blob to download\n   * @param options - optional configuration used to send requests to the service\n   * @returns - the downloaded blob\n   */\n  public async downloadBlob(\n    digest: string,\n    options: DownloadBlobOptions = {}\n  ): Promise<DownloadBlobResult> {\n    return tracingClient.withSpan(\n      \"ContainerRegistryContentClient.downloadBlob\",\n      options,\n      async (updatedOptions) => {\n        const initialResponse = await this.client.containerRegistryBlob.getBlob(\n          this.repositoryName,\n          digest,\n          updatedOptions\n        );\n\n        assertHasProperty(initialResponse, \"readableStreamBody\");\n        assertHasProperty(initialResponse, \"contentLength\");\n\n        const hash = crypto.createHash(\"sha256\");\n\n        return {\n          digest,\n          content: new RetriableReadableStream(\n            initialResponse.readableStreamBody,\n            async (pos) => {\n              const retryResponse = await this.client.containerRegistryBlob.getChunk(\n                this.repositoryName,\n                digest,\n                `${pos}-`,\n                updatedOptions\n              );\n\n              assertHasProperty(retryResponse, \"readableStreamBody\");\n              return retryResponse.readableStreamBody;\n            },\n            0,\n            initialResponse.contentLength,\n            {\n              onData: (data) => hash.write(data),\n              onEnd: () => {\n                hash.end();\n                const calculatedDigest = `sha256:${hash.digest(\"hex\")}`;\n\n                if (digest !== calculatedDigest) {\n                  throw new DigestMismatchError(\n                    \"Digest calculated from downloaded blob content does not match digest requested.\"\n                  );\n                }\n              },\n            }\n          ),\n        };\n      }\n    );\n  }\n}\n"]}