'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreAuth = require('@azure/core-auth');
var coreRestPipeline = require('@azure/core-rest-pipeline');
require('@azure/core-paging');
var logger$1 = require('@azure/logger');
var coreTracing = require('@azure/core-tracing');
var coreClient = require('@azure/core-client');
var crypto = require('crypto');
var stream = require('stream');
var abortController = require('@azure/abort-controller');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var coreClient__namespace = /*#__PURE__*/_interopNamespace(coreClient);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 *
 * @internal
 */
const logger = logger$1.createClientLogger("container-registry");

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const AcrErrors = {
    type: {
        name: "Composite",
        className: "AcrErrors",
        modelProperties: {
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AcrErrorInfo"
                        }
                    }
                }
            }
        }
    }
};
const AcrErrorInfo = {
    type: {
        name: "Composite",
        className: "AcrErrorInfo",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            },
            detail: {
                serializedName: "detail",
                type: {
                    name: "Dictionary",
                    value: { type: { name: "any" } }
                }
            }
        }
    }
};
const Repositories = {
    type: {
        name: "Composite",
        className: "Repositories",
        modelProperties: {
            repositories: {
                serializedName: "repositories",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRepositoryProperties = {
    type: {
        name: "Composite",
        className: "ContainerRepositoryProperties",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "imageName",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            manifestCount: {
                serializedName: "manifestCount",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            tagCount: {
                serializedName: "tagCount",
                required: true,
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            canDelete: {
                serializedName: "changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const RepositoryWriteableProperties = {
    type: {
        name: "Composite",
        className: "RepositoryWriteableProperties",
        modelProperties: {
            canDelete: {
                serializedName: "deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TagList = {
    type: {
        name: "Composite",
        className: "TagList",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                required: true,
                type: {
                    name: "String"
                }
            },
            repository: {
                serializedName: "imageName",
                required: true,
                type: {
                    name: "String"
                }
            },
            tagAttributeBases: {
                serializedName: "tags",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TagAttributesBase"
                        }
                    }
                }
            },
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagAttributesBase = {
    type: {
        name: "Composite",
        className: "TagAttributesBase",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            digest: {
                serializedName: "digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            canDelete: {
                serializedName: "changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const TagWriteableProperties = {
    type: {
        name: "Composite",
        className: "TagWriteableProperties",
        modelProperties: {
            canDelete: {
                serializedName: "deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ArtifactTagProperties = {
    type: {
        name: "Composite",
        className: "ArtifactTagProperties",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            repositoryName: {
                serializedName: "imageName",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "tag.name",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            digest: {
                serializedName: "tag.digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            createdOn: {
                serializedName: "tag.createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "tag.lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            canDelete: {
                serializedName: "tag.changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "tag.changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "tag.changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "tag.changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AcrManifests = {
    type: {
        name: "Composite",
        className: "AcrManifests",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                type: {
                    name: "String"
                }
            },
            repository: {
                serializedName: "imageName",
                type: {
                    name: "String"
                }
            },
            manifests: {
                serializedName: "manifests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManifestAttributesBase"
                        }
                    }
                }
            },
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManifestAttributesBase = {
    type: {
        name: "Composite",
        className: "ManifestAttributesBase",
        modelProperties: {
            digest: {
                serializedName: "digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "imageSize",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            createdOn: {
                serializedName: "createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            architecture: {
                serializedName: "architecture",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            operatingSystem: {
                serializedName: "os",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            relatedArtifacts: {
                serializedName: "references",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactManifestPlatform"
                        }
                    }
                }
            },
            tags: {
                serializedName: "tags",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            canDelete: {
                serializedName: "changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ArtifactManifestPlatform = {
    type: {
        name: "Composite",
        className: "ArtifactManifestPlatform",
        modelProperties: {
            digest: {
                serializedName: "digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            architecture: {
                serializedName: "architecture",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            operatingSystem: {
                serializedName: "os",
                readOnly: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManifestWriteableProperties = {
    type: {
        name: "Composite",
        className: "ManifestWriteableProperties",
        modelProperties: {
            canDelete: {
                serializedName: "deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const ArtifactManifestProperties = {
    type: {
        name: "Composite",
        className: "ArtifactManifestProperties",
        modelProperties: {
            registryLoginServer: {
                serializedName: "registry",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            repositoryName: {
                serializedName: "imageName",
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            digest: {
                serializedName: "manifest.digest",
                required: true,
                readOnly: true,
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "manifest.imageSize",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            createdOn: {
                serializedName: "manifest.createdTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedOn: {
                serializedName: "manifest.lastUpdateTime",
                required: true,
                readOnly: true,
                type: {
                    name: "DateTime"
                }
            },
            architecture: {
                serializedName: "manifest.architecture",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            operatingSystem: {
                serializedName: "manifest.os",
                readOnly: true,
                nullable: true,
                type: {
                    name: "String"
                }
            },
            relatedArtifacts: {
                serializedName: "manifest.references",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactManifestPlatform"
                        }
                    }
                }
            },
            tags: {
                serializedName: "manifest.tags",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            canDelete: {
                serializedName: "manifest.changeableAttributes.deleteEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canWrite: {
                serializedName: "manifest.changeableAttributes.writeEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canList: {
                serializedName: "manifest.changeableAttributes.listEnabled",
                type: {
                    name: "Boolean"
                }
            },
            canRead: {
                serializedName: "manifest.changeableAttributes.readEnabled",
                type: {
                    name: "Boolean"
                }
            }
        }
    }
};
const AcrRefreshToken = {
    type: {
        name: "Composite",
        className: "AcrRefreshToken",
        modelProperties: {
            refreshToken: {
                serializedName: "refresh_token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AcrAccessToken = {
    type: {
        name: "Composite",
        className: "AcrAccessToken",
        modelProperties: {
            accessToken: {
                serializedName: "access_token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const RepositoryTags = {
    type: {
        name: "Composite",
        className: "RepositoryTags",
        modelProperties: {
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const ImageSignature = {
    type: {
        name: "Composite",
        className: "ImageSignature",
        modelProperties: {
            header: {
                serializedName: "header",
                type: {
                    name: "Composite",
                    className: "Jwk"
                }
            },
            signature: {
                serializedName: "signature",
                type: {
                    name: "String"
                }
            },
            protected: {
                serializedName: "protected",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Jwk = {
    type: {
        name: "Composite",
        className: "Jwk",
        modelProperties: {
            jwk: {
                serializedName: "jwk",
                type: {
                    name: "Composite",
                    className: "JWKHeader"
                }
            },
            alg: {
                serializedName: "alg",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const JWKHeader = {
    type: {
        name: "Composite",
        className: "JWKHeader",
        modelProperties: {
            crv: {
                serializedName: "crv",
                type: {
                    name: "String"
                }
            },
            kid: {
                serializedName: "kid",
                type: {
                    name: "String"
                }
            },
            kty: {
                serializedName: "kty",
                type: {
                    name: "String"
                }
            },
            x: {
                serializedName: "x",
                type: {
                    name: "String"
                }
            },
            y: {
                serializedName: "y",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const History = {
    type: {
        name: "Composite",
        className: "History",
        modelProperties: {
            v1Compatibility: {
                serializedName: "v1Compatibility",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeleteRepositoryResult = {
    type: {
        name: "Composite",
        className: "DeleteRepositoryResult",
        modelProperties: {
            deletedManifests: {
                serializedName: "manifestsDeleted",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            deletedTags: {
                serializedName: "tagsDeleted",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const FsLayer = {
    type: {
        name: "Composite",
        className: "FsLayer",
        modelProperties: {
            blobSum: {
                serializedName: "blobSum",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Descriptor = {
    type: {
        name: "Composite",
        className: "Descriptor",
        modelProperties: {
            mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "Number"
                }
            },
            digest: {
                serializedName: "digest",
                type: {
                    name: "String"
                }
            },
            urls: {
                serializedName: "urls",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            annotations: {
                serializedName: "annotations",
                type: {
                    name: "Composite",
                    className: "Annotations"
                }
            }
        }
    }
};
const Annotations = {
    type: {
        name: "Composite",
        className: "Annotations",
        additionalProperties: { type: { name: "Object" } },
        modelProperties: {
            created: {
                serializedName: "org\\.opencontainers\\.image\\.created",
                type: {
                    name: "DateTime"
                }
            },
            authors: {
                serializedName: "org\\.opencontainers\\.image\\.authors",
                type: {
                    name: "String"
                }
            },
            url: {
                serializedName: "org\\.opencontainers\\.image\\.url",
                type: {
                    name: "String"
                }
            },
            documentation: {
                serializedName: "org\\.opencontainers\\.image\\.documentation",
                type: {
                    name: "String"
                }
            },
            source: {
                serializedName: "org\\.opencontainers\\.image\\.source",
                type: {
                    name: "String"
                }
            },
            version: {
                serializedName: "org\\.opencontainers\\.image\\.version",
                type: {
                    name: "String"
                }
            },
            revision: {
                serializedName: "org\\.opencontainers\\.image\\.revision",
                type: {
                    name: "String"
                }
            },
            vendor: {
                serializedName: "org\\.opencontainers\\.image\\.vendor",
                type: {
                    name: "String"
                }
            },
            licenses: {
                serializedName: "org\\.opencontainers\\.image\\.licenses",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "org\\.opencontainers\\.image\\.ref.name",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "org\\.opencontainers\\.image\\.title",
                type: {
                    name: "String"
                }
            },
            description: {
                serializedName: "org\\.opencontainers\\.image\\.description",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const TagAttributesTag = {
    type: {
        name: "Composite",
        className: "TagAttributesTag",
        modelProperties: {
            signatureRecord: {
                serializedName: "signatureRecord",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ManifestAttributesManifest = {
    type: {
        name: "Composite",
        className: "ManifestAttributesManifest",
        modelProperties: {
            references: {
                serializedName: "references",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ArtifactManifestPlatform"
                        }
                    }
                }
            }
        }
    }
};
const Manifest = {
    type: {
        name: "Composite",
        className: "Manifest",
        modelProperties: {
            schemaVersion: {
                serializedName: "schemaVersion",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ManifestListAttributes = {
    type: {
        name: "Composite",
        className: "ManifestListAttributes",
        modelProperties: {
            mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            },
            size: {
                serializedName: "size",
                type: {
                    name: "Number"
                }
            },
            digest: {
                serializedName: "digest",
                type: {
                    name: "String"
                }
            },
            platform: {
                serializedName: "platform",
                type: {
                    name: "Composite",
                    className: "Platform"
                }
            }
        }
    }
};
const Platform = {
    type: {
        name: "Composite",
        className: "Platform",
        modelProperties: {
            architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            },
            os: {
                serializedName: "os",
                type: {
                    name: "String"
                }
            },
            osVersion: {
                serializedName: "os\\.version",
                type: {
                    name: "String"
                }
            },
            osFeatures: {
                serializedName: "os\\.features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            variant: {
                serializedName: "variant",
                type: {
                    name: "String"
                }
            },
            features: {
                serializedName: "features",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            }
        }
    }
};
const OCIManifest = {
    serializedName: "application/vnd.oci.image.manifest.v1+json",
    type: {
        name: "Composite",
        className: "OCIManifest",
        modelProperties: {
            config: {
                serializedName: "config",
                type: {
                    name: "Composite",
                    className: "Descriptor"
                }
            },
            layers: {
                serializedName: "layers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Descriptor"
                        }
                    }
                }
            },
            annotations: {
                serializedName: "annotations",
                type: {
                    name: "Composite",
                    className: "Annotations"
                }
            },
            schemaVersion: {
                serializedName: "schemaVersion",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema = {
    type: {
        name: "Composite",
        className: "Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema",
        modelProperties: {
            grantType: {
                serializedName: "grant_type",
                required: true,
                type: {
                    name: "String"
                }
            },
            service: {
                serializedName: "service",
                required: true,
                type: {
                    name: "String"
                }
            },
            tenant: {
                serializedName: "tenant",
                type: {
                    name: "String"
                }
            },
            refreshToken: {
                serializedName: "refresh_token",
                type: {
                    name: "String"
                }
            },
            aadAccessToken: {
                serializedName: "access_token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema = {
    type: {
        name: "Composite",
        className: "PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema",
        modelProperties: {
            service: {
                serializedName: "service",
                required: true,
                type: {
                    name: "String"
                }
            },
            scope: {
                serializedName: "scope",
                required: true,
                type: {
                    name: "String"
                }
            },
            acrRefreshToken: {
                serializedName: "refresh_token",
                required: true,
                type: {
                    name: "String"
                }
            },
            grantType: {
                serializedName: "grant_type",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["refresh_token", "password"]
                }
            }
        }
    }
};
const ManifestWrapper = {
    type: {
        name: "Composite",
        className: "ManifestWrapper",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            }, manifests: {
                serializedName: "manifests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManifestListAttributes"
                        }
                    }
                }
            }, config: {
                serializedName: "config",
                type: {
                    name: "Composite",
                    className: "Descriptor"
                }
            }, layers: {
                serializedName: "layers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Descriptor"
                        }
                    }
                }
            }, annotations: {
                serializedName: "annotations",
                type: {
                    name: "Composite",
                    className: "Annotations"
                }
            }, architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            }, name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }, fsLayers: {
                serializedName: "fsLayers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FsLayer"
                        }
                    }
                }
            }, history: {
                serializedName: "history",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "History"
                        }
                    }
                }
            }, signatures: {
                serializedName: "signatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageSignature"
                        }
                    }
                }
            } })
    }
};
const ManifestList = {
    serializedName: "application/vnd.docker.distribution.manifest.list.v2+json",
    type: {
        name: "Composite",
        className: "ManifestList",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            }, manifests: {
                serializedName: "manifests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManifestListAttributes"
                        }
                    }
                }
            } })
    }
};
const V2Manifest = {
    serializedName: "application/vnd.docker.distribution.manifest.v2+json",
    type: {
        name: "Composite",
        className: "V2Manifest",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { mediaType: {
                serializedName: "mediaType",
                type: {
                    name: "String"
                }
            }, config: {
                serializedName: "config",
                type: {
                    name: "Composite",
                    className: "Descriptor"
                }
            }, layers: {
                serializedName: "layers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Descriptor"
                        }
                    }
                }
            } })
    }
};
const OCIIndex = {
    serializedName: "application/vnd.oci.image.index.v1+json",
    type: {
        name: "Composite",
        className: "OCIIndex",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { manifests: {
                serializedName: "manifests",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ManifestListAttributes"
                        }
                    }
                }
            }, annotations: {
                serializedName: "annotations",
                type: {
                    name: "Composite",
                    className: "Annotations"
                }
            } })
    }
};
const V1Manifest = {
    serializedName: "application/vnd.oci.image.manifest.v1+json",
    type: {
        name: "Composite",
        className: "V1Manifest",
        modelProperties: Object.assign(Object.assign({}, Manifest.type.modelProperties), { architecture: {
                serializedName: "architecture",
                type: {
                    name: "String"
                }
            }, name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            }, tag: {
                serializedName: "tag",
                type: {
                    name: "String"
                }
            }, fsLayers: {
                serializedName: "fsLayers",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "FsLayer"
                        }
                    }
                }
            }, history: {
                serializedName: "history",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "History"
                        }
                    }
                }
            }, signatures: {
                serializedName: "signatures",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ImageSignature"
                        }
                    }
                }
            } })
    }
};
const ContainerRegistryGetManifestHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetManifestHeaders",
        modelProperties: {
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            },
            mediaType: {
                serializedName: "content-type",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryCreateManifestHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryCreateManifestHeaders",
        modelProperties: {
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            },
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ContainerRegistryGetRepositoriesHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetRepositoriesHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetTagsHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetTagsHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetManifestsHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetManifestsHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetRepositoriesNextHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetRepositoriesNextHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetTagsNextHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetTagsNextHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryGetManifestsNextHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryGetManifestsNextHeaders",
        modelProperties: {
            link: {
                serializedName: "link",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobGetBlobHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobGetBlobHeaders",
        modelProperties: {
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobCheckBlobExistsHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobCheckBlobExistsHeaders",
        modelProperties: {
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobDeleteBlobHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobDeleteBlobHeaders",
        modelProperties: {
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobMountBlobHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobMountBlobHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            dockerUploadUuid: {
                serializedName: "docker-upload-uuid",
                type: {
                    name: "String"
                }
            },
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobGetUploadStatusHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobGetUploadStatusHeaders",
        modelProperties: {
            range: {
                serializedName: "range",
                type: {
                    name: "String"
                }
            },
            dockerUploadUuid: {
                serializedName: "docker-upload-uuid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobUploadChunkHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobUploadChunkHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            range: {
                serializedName: "range",
                type: {
                    name: "String"
                }
            },
            dockerUploadUuid: {
                serializedName: "docker-upload-uuid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobCompleteUploadHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobCompleteUploadHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            range: {
                serializedName: "range",
                type: {
                    name: "String"
                }
            },
            dockerContentDigest: {
                serializedName: "docker-content-digest",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobStartUploadHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobStartUploadHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            },
            range: {
                serializedName: "range",
                type: {
                    name: "String"
                }
            },
            dockerUploadUuid: {
                serializedName: "docker-upload-uuid",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobGetChunkHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobGetChunkHeaders",
        modelProperties: {
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentRange: {
                serializedName: "content-range",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ContainerRegistryBlobCheckChunkExistsHeaders = {
    type: {
        name: "Composite",
        className: "ContainerRegistryBlobCheckChunkExistsHeaders",
        modelProperties: {
            contentLength: {
                serializedName: "content-length",
                type: {
                    name: "Number"
                }
            },
            contentRange: {
                serializedName: "content-range",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AcrErrors: AcrErrors,
    AcrErrorInfo: AcrErrorInfo,
    Repositories: Repositories,
    ContainerRepositoryProperties: ContainerRepositoryProperties,
    RepositoryWriteableProperties: RepositoryWriteableProperties,
    TagList: TagList,
    TagAttributesBase: TagAttributesBase,
    TagWriteableProperties: TagWriteableProperties,
    ArtifactTagProperties: ArtifactTagProperties,
    AcrManifests: AcrManifests,
    ManifestAttributesBase: ManifestAttributesBase,
    ArtifactManifestPlatform: ArtifactManifestPlatform,
    ManifestWriteableProperties: ManifestWriteableProperties,
    ArtifactManifestProperties: ArtifactManifestProperties,
    AcrRefreshToken: AcrRefreshToken,
    AcrAccessToken: AcrAccessToken,
    RepositoryTags: RepositoryTags,
    ImageSignature: ImageSignature,
    Jwk: Jwk,
    JWKHeader: JWKHeader,
    History: History,
    DeleteRepositoryResult: DeleteRepositoryResult,
    FsLayer: FsLayer,
    Descriptor: Descriptor,
    Annotations: Annotations,
    TagAttributesTag: TagAttributesTag,
    ManifestAttributesManifest: ManifestAttributesManifest,
    Manifest: Manifest,
    ManifestListAttributes: ManifestListAttributes,
    Platform: Platform,
    OCIManifest: OCIManifest,
    Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema: Paths108HwamOauth2ExchangePostRequestbodyContentApplicationXWwwFormUrlencodedSchema,
    PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema: PathsV3R3RxOauth2TokenPostRequestbodyContentApplicationXWwwFormUrlencodedSchema,
    ManifestWrapper: ManifestWrapper,
    ManifestList: ManifestList,
    V2Manifest: V2Manifest,
    OCIIndex: OCIIndex,
    V1Manifest: V1Manifest,
    ContainerRegistryGetManifestHeaders: ContainerRegistryGetManifestHeaders,
    ContainerRegistryCreateManifestHeaders: ContainerRegistryCreateManifestHeaders,
    ContainerRegistryGetRepositoriesHeaders: ContainerRegistryGetRepositoriesHeaders,
    ContainerRegistryGetTagsHeaders: ContainerRegistryGetTagsHeaders,
    ContainerRegistryGetManifestsHeaders: ContainerRegistryGetManifestsHeaders,
    ContainerRegistryGetRepositoriesNextHeaders: ContainerRegistryGetRepositoriesNextHeaders,
    ContainerRegistryGetTagsNextHeaders: ContainerRegistryGetTagsNextHeaders,
    ContainerRegistryGetManifestsNextHeaders: ContainerRegistryGetManifestsNextHeaders,
    ContainerRegistryBlobGetBlobHeaders: ContainerRegistryBlobGetBlobHeaders,
    ContainerRegistryBlobCheckBlobExistsHeaders: ContainerRegistryBlobCheckBlobExistsHeaders,
    ContainerRegistryBlobDeleteBlobHeaders: ContainerRegistryBlobDeleteBlobHeaders,
    ContainerRegistryBlobMountBlobHeaders: ContainerRegistryBlobMountBlobHeaders,
    ContainerRegistryBlobGetUploadStatusHeaders: ContainerRegistryBlobGetUploadStatusHeaders,
    ContainerRegistryBlobUploadChunkHeaders: ContainerRegistryBlobUploadChunkHeaders,
    ContainerRegistryBlobCompleteUploadHeaders: ContainerRegistryBlobCompleteUploadHeaders,
    ContainerRegistryBlobStartUploadHeaders: ContainerRegistryBlobStartUploadHeaders,
    ContainerRegistryBlobGetChunkHeaders: ContainerRegistryBlobGetChunkHeaders,
    ContainerRegistryBlobCheckChunkExistsHeaders: ContainerRegistryBlobCheckChunkExistsHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const url = {
    parameterPath: "url",
    mapper: {
        serializedName: "url",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const name = {
    parameterPath: "name",
    mapper: {
        serializedName: "name",
        required: true,
        type: {
            name: "String"
        }
    }
};
const reference = {
    parameterPath: "reference",
    mapper: {
        serializedName: "reference",
        required: true,
        type: {
            name: "String"
        }
    }
};
const accept1 = {
    parameterPath: ["options", "accept"],
    mapper: {
        serializedName: "accept",
        type: {
            name: "String"
        }
    }
};
const payload = {
    parameterPath: "payload",
    mapper: {
        serializedName: "payload",
        required: true,
        type: {
            name: "Stream"
        }
    }
};
const accept2 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const last = {
    parameterPath: ["options", "last"],
    mapper: {
        serializedName: "last",
        type: {
            name: "String"
        }
    }
};
const n = {
    parameterPath: ["options", "n"],
    mapper: {
        serializedName: "n",
        type: {
            name: "Number"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        serializedName: "api-version",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const value = {
    parameterPath: ["options", "value"],
    mapper: RepositoryWriteableProperties
};
const orderby = {
    parameterPath: ["options", "orderby"],
    mapper: {
        serializedName: "orderby",
        type: {
            name: "String"
        }
    }
};
const digest = {
    parameterPath: ["options", "digest"],
    mapper: {
        serializedName: "digest",
        type: {
            name: "String"
        }
    }
};
const value1 = {
    parameterPath: ["options", "value"],
    mapper: TagWriteableProperties
};
const digest1 = {
    parameterPath: "digest",
    mapper: {
        serializedName: "digest",
        required: true,
        type: {
            name: "String"
        }
    }
};
const value2 = {
    parameterPath: ["options", "value"],
    mapper: ManifestWriteableProperties
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const accept3 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const fromParam = {
    parameterPath: "fromParam",
    mapper: {
        serializedName: "from",
        required: true,
        type: {
            name: "String"
        }
    }
};
const mount = {
    parameterPath: "mount",
    mapper: {
        serializedName: "mount",
        required: true,
        type: {
            name: "String"
        }
    }
};
const nextLink1 = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextBlobUuidLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const contentType2 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/octet-stream",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const value3 = {
    parameterPath: "value",
    mapper: {
        serializedName: "value",
        required: true,
        type: {
            name: "Stream"
        }
    }
};
const value4 = {
    parameterPath: ["options", "value"],
    mapper: {
        serializedName: "value",
        type: {
            name: "Stream"
        }
    }
};
const digest2 = {
    parameterPath: "digest",
    mapper: {
        serializedName: "digest",
        required: true,
        type: {
            name: "String"
        }
    }
};
const range = {
    parameterPath: "range",
    mapper: {
        serializedName: "Range",
        required: true,
        type: {
            name: "String"
        }
    }
};
const contentType3 = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/x-www-form-urlencoded",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const grantType = {
    parameterPath: "grantType",
    mapper: {
        serializedName: "grant_type",
        required: true,
        type: {
            name: "String"
        }
    }
};
const service = {
    parameterPath: "service",
    mapper: {
        serializedName: "service",
        required: true,
        type: {
            name: "String"
        }
    }
};
const tenant = {
    parameterPath: ["options", "tenant"],
    mapper: {
        serializedName: "tenant",
        type: {
            name: "String"
        }
    }
};
const refreshToken = {
    parameterPath: ["options", "refreshToken"],
    mapper: {
        serializedName: "refresh_token",
        type: {
            name: "String"
        }
    }
};
const accessToken = {
    parameterPath: ["options", "accessToken"],
    mapper: {
        serializedName: "access_token",
        type: {
            name: "String"
        }
    }
};
const accept4 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const scope = {
    parameterPath: "scope",
    mapper: {
        serializedName: "scope",
        required: true,
        type: {
            name: "String"
        }
    }
};
const refreshToken1 = {
    parameterPath: "refreshToken",
    mapper: {
        serializedName: "refresh_token",
        required: true,
        type: {
            name: "String"
        }
    }
};
const grantType1 = {
    parameterPath: "grantType",
    mapper: {
        serializedName: "grant_type",
        required: true,
        type: {
            name: "Enum",
            allowedValues: ["refresh_token", "password"]
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ContainerRegistry operations. */
class ContainerRegistryImpl {
    /**
     * Initialize a new instance of the class ContainerRegistry class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Tells whether this Docker Registry instance supports Docker Registry HTTP API v2
     * @param options The options parameters.
     */
    checkDockerV2Support(options) {
        return this.client.sendOperationRequest({ options }, checkDockerV2SupportOperationSpec);
    }
    /**
     * Get the manifest identified by `name` and `reference` where `reference` can be a tag or digest.
     * @param name Name of the image (including the namespace)
     * @param reference A tag or a digest, pointing to a specific image
     * @param options The options parameters.
     */
    getManifest(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, getManifestOperationSpec);
    }
    /**
     * Put the manifest identified by `name` and `reference` where `reference` can be a tag or digest.
     * @param name Name of the image (including the namespace)
     * @param reference A tag or a digest, pointing to a specific image
     * @param payload Manifest body, can take v1 or v2 values depending on accept header
     * @param options The options parameters.
     */
    createManifest(name, reference, payload, options) {
        return this.client.sendOperationRequest({ name, reference, payload, options }, createManifestOperationSpec);
    }
    /**
     * Delete the manifest identified by `name` and `reference`. Note that a manifest can _only_ be deleted
     * by `digest`.
     * @param name Name of the image (including the namespace)
     * @param reference Digest of a BLOB
     * @param options The options parameters.
     */
    deleteManifest(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, deleteManifestOperationSpec);
    }
    /**
     * List repositories
     * @param options The options parameters.
     */
    getRepositories(options) {
        return this.client.sendOperationRequest({ options }, getRepositoriesOperationSpec);
    }
    /**
     * Get repository attributes
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    getProperties(name, options) {
        return this.client.sendOperationRequest({ name, options }, getPropertiesOperationSpec);
    }
    /**
     * Delete the repository identified by `name`
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    deleteRepository(name, options) {
        return this.client.sendOperationRequest({ name, options }, deleteRepositoryOperationSpec);
    }
    /**
     * Update the attribute identified by `name` where `reference` is the name of the repository.
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    updateProperties(name, options) {
        return this.client.sendOperationRequest({ name, options }, updatePropertiesOperationSpec);
    }
    /**
     * List tags of a repository
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    getTags(name, options) {
        return this.client.sendOperationRequest({ name, options }, getTagsOperationSpec);
    }
    /**
     * Get tag attributes by tag
     * @param name Name of the image (including the namespace)
     * @param reference Tag name
     * @param options The options parameters.
     */
    getTagProperties(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, getTagPropertiesOperationSpec);
    }
    /**
     * Update tag attributes
     * @param name Name of the image (including the namespace)
     * @param reference Tag name
     * @param options The options parameters.
     */
    updateTagAttributes(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, updateTagAttributesOperationSpec);
    }
    /**
     * Delete tag
     * @param name Name of the image (including the namespace)
     * @param reference Tag name
     * @param options The options parameters.
     */
    deleteTag(name, reference, options) {
        return this.client.sendOperationRequest({ name, reference, options }, deleteTagOperationSpec);
    }
    /**
     * List manifests of a repository
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    getManifests(name, options) {
        return this.client.sendOperationRequest({ name, options }, getManifestsOperationSpec);
    }
    /**
     * Get manifest attributes
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    getManifestProperties(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, getManifestPropertiesOperationSpec);
    }
    /**
     * Update properties of a manifest
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    updateManifestProperties(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, updateManifestPropertiesOperationSpec);
    }
    /**
     * GetRepositoriesNext
     * @param nextLink The nextLink from the previous successful call to the GetRepositories method.
     * @param options The options parameters.
     */
    getRepositoriesNext(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getRepositoriesNextOperationSpec);
    }
    /**
     * GetTagsNext
     * @param name Name of the image (including the namespace)
     * @param nextLink The nextLink from the previous successful call to the GetTags method.
     * @param options The options parameters.
     */
    getTagsNext(name, nextLink, options) {
        return this.client.sendOperationRequest({ name, nextLink, options }, getTagsNextOperationSpec);
    }
    /**
     * GetManifestsNext
     * @param name Name of the image (including the namespace)
     * @param nextLink The nextLink from the previous successful call to the GetManifests method.
     * @param options The options parameters.
     */
    getManifestsNext(name, nextLink, options) {
        return this.client.sendOperationRequest({ name, nextLink, options }, getManifestsNextOperationSpec);
    }
}
// Operation Specifications
const serializer$2 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const checkDockerV2SupportOperationSpec = {
    path: "/v2/",
    httpMethod: "GET",
    responses: {
        200: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url],
    headerParameters: [accept],
    serializer: serializer$2
};
const getManifestOperationSpec = {
    path: "/v2/{name}/manifests/{reference}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: ContainerRegistryGetManifestHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, reference],
    headerParameters: [accept, accept1],
    serializer: serializer$2
};
const createManifestOperationSpec = {
    path: "/v2/{name}/manifests/{reference}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ContainerRegistryCreateManifestHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: payload,
    urlParameters: [url, name, reference],
    headerParameters: [accept2, contentType],
    mediaType: "binary",
    serializer: serializer$2
};
const deleteManifestOperationSpec = {
    path: "/v2/{name}/manifests/{reference}",
    httpMethod: "DELETE",
    responses: {
        202: {},
        404: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, reference],
    headerParameters: [accept],
    serializer: serializer$2
};
const getRepositoriesOperationSpec = {
    path: "/acr/v1/_catalog",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Repositories,
            headersMapper: ContainerRegistryGetRepositoriesHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [last, n, apiVersion],
    urlParameters: [url],
    headerParameters: [accept],
    serializer: serializer$2
};
const getPropertiesOperationSpec = {
    path: "/acr/v1/{name}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ContainerRepositoryProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const deleteRepositoryOperationSpec = {
    path: "/acr/v1/{name}",
    httpMethod: "DELETE",
    responses: {
        202: {},
        404: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const updatePropertiesOperationSpec = {
    path: "/acr/v1/{name}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ContainerRepositoryProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value,
    queryParameters: [apiVersion],
    urlParameters: [url, name],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer: serializer$2
};
const getTagsOperationSpec = {
    path: "/acr/v1/{name}/_tags",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagList,
            headersMapper: ContainerRegistryGetTagsHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [
        last,
        n,
        apiVersion,
        orderby,
        digest
    ],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const getTagPropertiesOperationSpec = {
    path: "/acr/v1/{name}/_tags/{reference}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactTagProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name, reference],
    headerParameters: [accept],
    serializer: serializer$2
};
const updateTagAttributesOperationSpec = {
    path: "/acr/v1/{name}/_tags/{reference}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ArtifactTagProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value1,
    queryParameters: [apiVersion],
    urlParameters: [url, name, reference],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer: serializer$2
};
const deleteTagOperationSpec = {
    path: "/acr/v1/{name}/_tags/{reference}",
    httpMethod: "DELETE",
    responses: {
        202: {},
        404: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name, reference],
    headerParameters: [accept],
    serializer: serializer$2
};
const getManifestsOperationSpec = {
    path: "/acr/v1/{name}/_manifests",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AcrManifests,
            headersMapper: ContainerRegistryGetManifestsHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [
        last,
        n,
        apiVersion,
        orderby
    ],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer: serializer$2
};
const getManifestPropertiesOperationSpec = {
    path: "/acr/v1/{name}/_manifests/{digest}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ArtifactManifestProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [apiVersion],
    urlParameters: [url, name, digest1],
    headerParameters: [accept],
    serializer: serializer$2
};
const updateManifestPropertiesOperationSpec = {
    path: "/acr/v1/{name}/_manifests/{digest}",
    httpMethod: "PATCH",
    responses: {
        200: {
            bodyMapper: ArtifactManifestProperties
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value2,
    queryParameters: [apiVersion],
    urlParameters: [url, name, digest1],
    headerParameters: [accept, contentType1],
    mediaType: "json",
    serializer: serializer$2
};
const getRepositoriesNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Repositories,
            headersMapper: ContainerRegistryGetRepositoriesNextHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, nextLink],
    headerParameters: [accept],
    serializer: serializer$2
};
const getTagsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: TagList,
            headersMapper: ContainerRegistryGetTagsNextHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, nextLink],
    headerParameters: [accept],
    serializer: serializer$2
};
const getManifestsNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: AcrManifests,
            headersMapper: ContainerRegistryGetManifestsNextHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, nextLink],
    headerParameters: [accept],
    serializer: serializer$2
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing ContainerRegistryBlob operations. */
class ContainerRegistryBlobImpl {
    /**
     * Initialize a new instance of the class ContainerRegistryBlob class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Retrieve the blob from the registry identified by digest.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    getBlob(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, getBlobOperationSpec);
    }
    /**
     * Same as GET, except only the headers are returned.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    checkBlobExists(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, checkBlobExistsOperationSpec);
    }
    /**
     * Removes an already uploaded blob.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param options The options parameters.
     */
    deleteBlob(name, digest, options) {
        return this.client.sendOperationRequest({ name, digest, options }, deleteBlobOperationSpec);
    }
    /**
     * Mount a blob identified by the `mount` parameter from another repository.
     * @param name Name of the image (including the namespace)
     * @param fromParam Name of the source repository.
     * @param mount Digest of blob to mount from the source repository.
     * @param options The options parameters.
     */
    mountBlob(name, fromParam, mount, options) {
        return this.client.sendOperationRequest({ name, fromParam, mount, options }, mountBlobOperationSpec);
    }
    /**
     * Retrieve status of upload identified by uuid. The primary purpose of this endpoint is to resolve the
     * current status of a resumable upload.
     * @param nextLink Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    getUploadStatus(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, getUploadStatusOperationSpec);
    }
    /**
     * Upload a stream of data without completing the upload.
     * @param nextLink Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param value Raw data of blob
     * @param options The options parameters.
     */
    uploadChunk(nextLink, value, options) {
        return this.client.sendOperationRequest({ nextLink, value, options }, uploadChunkOperationSpec);
    }
    /**
     * Complete the upload, providing all the data in the body, if necessary. A request without a body will
     * just complete the upload with previously uploaded content.
     * @param digest Digest of a BLOB
     * @param nextLink Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    completeUpload(digest, nextLink, options) {
        return this.client.sendOperationRequest({ digest, nextLink, options }, completeUploadOperationSpec);
    }
    /**
     * Cancel outstanding upload processes, releasing associated resources. If this is not called, the
     * unfinished uploads will eventually timeout.
     * @param nextLink Link acquired from upload start or previous chunk. Note, do not include initial /
     *                 (must do substring(1) )
     * @param options The options parameters.
     */
    cancelUpload(nextLink, options) {
        return this.client.sendOperationRequest({ nextLink, options }, cancelUploadOperationSpec);
    }
    /**
     * Initiate a resumable blob upload with an empty request body.
     * @param name Name of the image (including the namespace)
     * @param options The options parameters.
     */
    startUpload(name, options) {
        return this.client.sendOperationRequest({ name, options }, startUploadOperationSpec);
    }
    /**
     * Retrieve the blob from the registry identified by `digest`. This endpoint may also support RFC7233
     * compliant range requests. Support can be detected by issuing a HEAD request. If the header
     * `Accept-Range: bytes` is returned, range requests can be used to fetch partial content.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param range Format : bytes=<start>-<end>,  HTTP Range header specifying blob chunk.
     * @param options The options parameters.
     */
    getChunk(name, digest, range, options) {
        return this.client.sendOperationRequest({ name, digest, range, options }, getChunkOperationSpec);
    }
    /**
     * Same as GET, except only the headers are returned.
     * @param name Name of the image (including the namespace)
     * @param digest Digest of a BLOB
     * @param range Format : bytes=<start>-<end>,  HTTP Range header specifying blob chunk.
     * @param options The options parameters.
     */
    checkChunkExists(name, digest, range, options) {
        return this.client.sendOperationRequest({ name, digest, range, options }, checkChunkExistsOperationSpec);
    }
}
// Operation Specifications
const serializer$1 = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const getBlobOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: ContainerRegistryBlobGetBlobHeaders
        },
        307: {
            headersMapper: ContainerRegistryBlobGetBlobHeaders
        },
        default: {}
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept3],
    serializer: serializer$1
};
const checkBlobExistsOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ContainerRegistryBlobCheckBlobExistsHeaders
        },
        307: {
            headersMapper: ContainerRegistryBlobCheckBlobExistsHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept],
    serializer: serializer$1
};
const deleteBlobOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "DELETE",
    responses: {
        202: {
            headersMapper: ContainerRegistryBlobDeleteBlobHeaders
        },
        404: {},
        default: {}
    },
    urlParameters: [url, name, digest1],
    serializer: serializer$1
};
const mountBlobOperationSpec = {
    path: "/v2/{name}/blobs/uploads/",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: ContainerRegistryBlobMountBlobHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    queryParameters: [fromParam, mount],
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer: serializer$1
};
const getUploadStatusOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "GET",
    responses: {
        204: {
            headersMapper: ContainerRegistryBlobGetUploadStatusHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, nextLink1],
    headerParameters: [accept],
    serializer: serializer$1
};
const uploadChunkOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "PATCH",
    responses: {
        202: {
            headersMapper: ContainerRegistryBlobUploadChunkHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value3,
    urlParameters: [url, nextLink1],
    headerParameters: [accept2, contentType2],
    mediaType: "binary",
    serializer: serializer$1
};
const completeUploadOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "PUT",
    responses: {
        201: {
            headersMapper: ContainerRegistryBlobCompleteUploadHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    requestBody: value4,
    queryParameters: [digest2],
    urlParameters: [url, nextLink1],
    headerParameters: [accept2, contentType2],
    mediaType: "binary",
    serializer: serializer$1
};
const cancelUploadOperationSpec = {
    path: "/{nextBlobUuidLink}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, nextLink1],
    headerParameters: [accept],
    serializer: serializer$1
};
const startUploadOperationSpec = {
    path: "/v2/{name}/blobs/uploads/",
    httpMethod: "POST",
    responses: {
        202: {
            headersMapper: ContainerRegistryBlobStartUploadHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name],
    headerParameters: [accept],
    serializer: serializer$1
};
const getChunkOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "GET",
    responses: {
        206: {
            bodyMapper: {
                type: { name: "Stream" },
                serializedName: "parsedResponse"
            },
            headersMapper: ContainerRegistryBlobGetChunkHeaders
        },
        default: {}
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept3, range],
    serializer: serializer$1
};
const checkChunkExistsOperationSpec = {
    path: "/v2/{name}/blobs/{digest}",
    httpMethod: "HEAD",
    responses: {
        200: {
            headersMapper: ContainerRegistryBlobCheckChunkExistsHeaders
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    urlParameters: [url, name, digest1],
    headerParameters: [accept, range],
    serializer: serializer$1
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** Class containing Authentication operations. */
class AuthenticationImpl {
    /**
     * Initialize a new instance of the class Authentication class.
     * @param client Reference to the service client
     */
    constructor(client) {
        this.client = client;
    }
    /**
     * Exchange AAD tokens for an ACR refresh Token
     * @param grantType Can take a value of access_token_refresh_token, or access_token, or refresh_token
     * @param service Indicates the name of your Azure container registry.
     * @param options The options parameters.
     */
    exchangeAadAccessTokenForAcrRefreshToken(grantType, service, options) {
        return this.client.sendOperationRequest({ grantType, service, options }, exchangeAadAccessTokenForAcrRefreshTokenOperationSpec);
    }
    /**
     * Exchange ACR Refresh token for an ACR Access Token
     * @param service Indicates the name of your Azure container registry.
     * @param scope Which is expected to be a valid scope, and can be specified more than once for multiple
     *              scope requests. You obtained this from the Www-Authenticate response header from the challenge.
     * @param refreshToken Must be a valid ACR refresh token
     * @param grantType Grant type is expected to be refresh_token
     * @param options The options parameters.
     */
    exchangeAcrRefreshTokenForAcrAccessToken(service, scope, refreshToken, grantType, options) {
        return this.client.sendOperationRequest({ service, scope, refreshToken, grantType, options }, exchangeAcrRefreshTokenForAcrAccessTokenOperationSpec);
    }
}
// Operation Specifications
const serializer = coreClient__namespace.createSerializer(Mappers, /* isXml */ false);
const exchangeAadAccessTokenForAcrRefreshTokenOperationSpec = {
    path: "/oauth2/exchange",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AcrRefreshToken
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    formDataParameters: [
        grantType,
        service,
        tenant,
        refreshToken,
        accessToken
    ],
    queryParameters: [apiVersion],
    urlParameters: [url],
    headerParameters: [contentType3, accept4],
    serializer
};
const exchangeAcrRefreshTokenForAcrAccessTokenOperationSpec = {
    path: "/oauth2/token",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: AcrAccessToken
        },
        default: {
            bodyMapper: AcrErrors
        }
    },
    formDataParameters: [
        service,
        scope,
        refreshToken1,
        grantType1
    ],
    queryParameters: [apiVersion],
    urlParameters: [url],
    headerParameters: [contentType3, accept4],
    serializer
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/** @internal */
class GeneratedClient extends coreClient__namespace.ServiceClient {
    /**
     * Initializes a new instance of the GeneratedClient class.
     * @param url Registry login URL
     * @param apiVersion Api Version
     * @param options The parameter options
     */
    constructor(url, apiVersion, options) {
        var _a, _b;
        if (url === undefined) {
            throw new Error("'url' cannot be null");
        }
        if (apiVersion === undefined) {
            throw new Error("'apiVersion' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaults = {
            requestContentType: "application/json; charset=utf-8"
        };
        const packageDetails = `azsdk-js-container-registry/1.1.0-beta.4`;
        const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix
            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`
            : `${packageDetails}`;
        const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
                userAgentPrefix
            }, endpoint: (_b = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri) !== null && _b !== void 0 ? _b : "{url}" });
        super(optionsWithDefaults);
        // Parameter assignments
        this.url = url;
        this.apiVersion = apiVersion;
        this.containerRegistry = new ContainerRegistryImpl(this);
        this.containerRegistryBlob = new ContainerRegistryBlobImpl(this);
        this.authentication = new AuthenticationImpl(this);
        this.addCustomApiVersionPolicy(apiVersion);
    }
    /** A function that adds a policy that sets the api-version (or equivalent) to reflect the library version. */
    addCustomApiVersionPolicy(apiVersion) {
        if (!apiVersion) {
            return;
        }
        const apiVersionPolicy = {
            name: "CustomApiVersionPolicy",
            async sendRequest(request, next) {
                const param = request.url.split("?");
                if (param.length > 1) {
                    const newParams = param[1].split("&").map((item) => {
                        if (item.indexOf("api-version") > -1) {
                            return "api-version=" + apiVersion;
                        }
                        else {
                            return item;
                        }
                    });
                    request.url = param[0] + "?" + newParams.join("&");
                }
                return next(request);
            }
        };
        this.pipeline.addPolicy(apiVersionPolicy);
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "1.1.0";

// Copyright (c) Microsoft Corporation.
/** @internal */
const tracingClient = coreTracing.createTracingClient({
    namespace: "Microsoft.ContainerRegistry",
    packageName: "@azure/container-registry",
    packageVersion: SDK_VERSION,
});

// Copyright (c) Microsoft Corporation.
/**
 * Extract the path part from the next link value returned by the service,
 * @internal
 */
function extractNextLink(value) {
    // The link value has this pattern
    //     `</acr/v1/name/...&n=2&orderby=>; rel="next"`
    // and we only want the part inside of <...>
    return value === null || value === void 0 ? void 0 : value.substr(1, value.indexOf(">") - 1);
}
/**
 * Checks whether a string is a digest
 * @internal
 */
function isDigest(tagOrDigest) {
    return tagOrDigest.includes(":");
}
async function readStreamToEnd(stream, maxLength) {
    const buffers = [];
    let bytesRead = 0;
    return new Promise((resolve, reject) => {
        stream.on("data", (chunk) => {
            buffers.push(chunk);
            bytesRead += chunk.length;
            if (maxLength && bytesRead > maxLength) {
                reject(new Error(`Stream exceeded maximum allowed length of ${maxLength} bytes.`));
            }
        });
        stream.on("end", () => resolve(Buffer.concat(buffers)));
        stream.on("error", (err) => reject(err));
    });
}
function readChunksFromStream(stream, chunkSize) {
    return tslib.__asyncGenerator(this, arguments, function* readChunksFromStream_1() {
        var _a, e_1, _b, _c;
        let chunk = Buffer.alloc(chunkSize);
        let chunkCursor = 0;
        try {
            for (var _d = true, stream_1 = tslib.__asyncValues(stream), stream_1_1; stream_1_1 = yield tslib.__await(stream_1.next()), _a = stream_1_1.done, !_a;) {
                _c = stream_1_1.value;
                _d = false;
                try {
                    const data = _c;
                    const dataAsBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, "utf8");
                    let dataCursor = 0;
                    while (dataCursor < dataAsBuffer.length) {
                        const bytesCopied = dataAsBuffer.copy(chunk, chunkCursor, dataCursor);
                        dataCursor += bytesCopied;
                        chunkCursor += bytesCopied;
                        if (chunkCursor >= chunkSize) {
                            yield yield tslib.__await(chunk);
                            chunkCursor = 0;
                            chunk = Buffer.alloc(chunkSize);
                        }
                    }
                }
                finally {
                    _d = true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = stream_1.return)) yield tslib.__await(_b.call(stream_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (chunkCursor > 0) {
            yield yield tslib.__await(chunk.subarray(0, chunkCursor));
        }
    });
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Parses an WWW-Authenticate response.
 * This transforms a string value like:
 * `Bearer authorization="some_authorization", resource="https://some.url"`
 * into an object like:
 * `{ authorization: "some_authorization", resource: "https://some.url" }`
 * @param wwwAuthenticate - String value in the WWW-Authenticate header
 */
function parseWWWAuthenticate(wwwAuthenticate) {
    // Match on things that look like property name/value pairs. We assume that values are quoted,
    // this hasn't been an issue yet...
    const pattern = /(\w+?)="(.*?)"/g;
    const value = {};
    let match;
    while ((match = pattern.exec(wwwAuthenticate)) !== null) {
        value[match[1]] = match[2];
    }
    return value;
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function delay(t, value) {
    return new Promise((resolve) => setTimeout(() => resolve(value), t));
}
// Default options for the cycler if none are provided
const DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry
};
/**
 * Converts an an unreliable access token getter (which may resolve with null)
 * into an AccessTokenGetter by retrying the unreliable getter in a regular
 * interval.
 *
 * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.
 * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.
 * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.
 * @returns - A promise that, if it resolves, will resolve with an access token.
 */
async function beginRefresh(getAccessToken, retryIntervalInMs, refreshTimeout) {
    // This wrapper handles exceptions gracefully as long as we haven't exceeded
    // the timeout.
    async function tryGetAccessToken() {
        if (Date.now() < refreshTimeout) {
            try {
                return await getAccessToken();
            }
            catch (_a) {
                return null;
            }
        }
        else {
            const finalToken = await getAccessToken();
            // Timeout is up, so throw if it's still null
            if (finalToken === null) {
                throw new Error("Failed to refresh access token.");
            }
            return finalToken;
        }
    }
    let token = await tryGetAccessToken();
    while (token === null) {
        await delay(retryIntervalInMs);
        token = await tryGetAccessToken();
    }
    return token;
}
/**
 * Creates a token cycler from a credential, scopes, and optional settings.
 *
 * A token cycler represents a way to reliably retrieve a valid access token
 * from a TokenCredential. It will handle initializing the token, refreshing it
 * when it nears expiration, and synchronizes refresh attempts to avoid
 * concurrency hazards.
 *
 * @param credential - the underlying TokenCredential that provides the access
 * token
 * @param tokenCyclerOptions - optionally override default settings for the cycler
 *
 * @returns - a function that reliably produces a valid access token
 */
function createTokenCycler(credential, tokenCyclerOptions) {
    let refreshWorker = null;
    let token = null;
    const options = Object.assign(Object.assign({}, DEFAULT_CYCLER_OPTIONS), tokenCyclerOptions);
    /**
     * This little holder defines several predicates that we use to construct
     * the rules of refreshing the token.
     */
    const cycler = {
        /**
         * Produces true if a refresh job is currently in progress.
         */
        get isRefreshing() {
            return refreshWorker !== null;
        },
        /**
         * Produces true if the cycler SHOULD refresh (we are within the refresh
         * window and not already refreshing)
         */
        get shouldRefresh() {
            var _a;
            return (!cycler.isRefreshing &&
                ((_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : 0) - options.refreshWindowInMs < Date.now());
        },
        /**
         * Produces true if the cycler MUST refresh (null or nearly-expired
         * token).
         */
        get mustRefresh() {
            return (token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now());
        },
    };
    /**
     * Starts a refresh job or returns the existing job if one is already
     * running.
     */
    function refresh(scopes, getTokenOptions) {
        var _a;
        if (!cycler.isRefreshing) {
            // We bind `scopes` here to avoid passing it around a lot
            const tryGetAccessToken = () => credential.getToken(scopes, getTokenOptions);
            // Take advantage of promise chaining to insert an assignment to `token`
            // before the refresh can be considered done.
            refreshWorker = beginRefresh(tryGetAccessToken, options.retryIntervalInMs, 
            // If we don't have a token, then we should timeout immediately
            (_a = token === null || token === void 0 ? void 0 : token.expiresOnTimestamp) !== null && _a !== void 0 ? _a : Date.now())
                .then((_token) => {
                refreshWorker = null;
                token = _token;
                return token;
            })
                .catch((reason) => {
                // We also should reset the refresher if we enter a failed state.  All
                // existing awaiters will throw, but subsequent requests will start a
                // new retry chain.
                refreshWorker = null;
                token = null;
                throw reason;
            });
        }
        return refreshWorker;
    }
    return {
        get cachedToken() {
            return token || undefined;
        },
        getToken: async (scopes, tokenOptions) => {
            //
            // Simple rules:
            // - If we MUST refresh, then return the refresh task, blocking
            //   the pipeline until a token is available.
            // - If we SHOULD refresh, then run refresh but don't return it
            //   (we can still use the cached token).
            // - Return the token, since it's fine if we didn't return in
            //   step 1.
            //
            if (cycler.mustRefresh)
                return refresh(scopes, tokenOptions);
            if (cycler.shouldRefresh) {
                refresh(scopes, tokenOptions);
            }
            return token;
        },
    };
}

// Copyright (c) Microsoft Corporation.
const fiveMinutesInMs = 5 * 60 * 1000;
/**
 * Handles challenge based authentication for Container Registry Service.
 *```
 *  The challenge-based authorization flow for ACR is illustrated in the following steps.
 *  For example, GET /api/v1/acr/repositories translates into the following calls.
 *      Step 1: GET /api/v1/acr/repositories
 *  Return Header: 401: www-authenticate header - Bearer realm="{url}",service="{serviceName}",scope="{scope}",error="invalid_token"
 *      Step 2: Retrieve the serviceName, scope from the WWW-Authenticate header.  (Parse the string.)
 *      Step 3: POST /api/oauth2/exchange
 *  Request Body : { service, scope, grant-type, aadToken with ARM scope }
 *  Response Body: { acrRefreshToken }
 *      Step 4: POST /api/oauth2/token
 *  Request Body: { acrRefreshToken, scope, grant-type }
 *  Response Body: { acrAccessToken }
 *      Step 5: GET /api/v1/acr/repositories
 *  Request Header: { Bearer acrTokenAccess }
 *```
 */
class ChallengeHandler {
    constructor(credential, options = {}) {
        this.credential = credential;
        this.options = options;
        this.cycler = createTokenCycler(credential, {
            refreshWindowInMs: fiveMinutesInMs,
        });
    }
    authorizeRequest(options) {
        // Try using the existing token in case we don't need to refresh.
        if (this.cachedAcrAccessToken) {
            options.request.headers.set("Authorization", `Bearer ${this.cachedAcrAccessToken}`);
        }
        return Promise.resolve();
    }
    /**
     * Updates  the authentication context based on the challenge.
     */
    async authorizeRequestOnChallenge(options) {
        var _a;
        // Once we're here, we've completed Step 1.
        const challenge = (_a = options.response) === null || _a === void 0 ? void 0 : _a.headers.get("WWW-Authenticate");
        if (!challenge) {
            throw new Error("Failed to retrieve challenge from response headers");
        }
        // Step 2: Parse challenge string to retrieve serviceName and scope, where scope is the ACR Scope
        const { service, scope } = parseWWWAuthenticate(challenge);
        if (!service) {
            throw new Error("Failed to retrieve 'service' from challenge");
        }
        if (!scope) {
            throw new Error("Failed to retrieve 'scope' from challenge");
        }
        // Step 3: Exchange AAD Access Token for ACR Refresh Token
        //   For anonymous access, we send the request with grant_type=password and an empty ACR refresh token
        //   For non-anonymous access, we get an AAD token then exchange it for an ACR fresh token
        let grantType;
        let acrRefreshToken;
        if (this.credential.isAnonymousAccess) {
            grantType = "password";
            acrRefreshToken = "";
        }
        else {
            grantType = "refresh_token";
            acrRefreshToken = (await this.cycler.getToken(scope, Object.assign(Object.assign({}, options), { service }))).token;
        }
        // Step 4: Send in acrRefreshToken and get back acrAccessToken
        const acrAccessToken = await this.credential.tokenService.ExchangeAcrRefreshTokenForAcrAccessTokenAsync(acrRefreshToken, service, scope, grantType, this.options);
        // Step 5 - Authorize Request.  At this point we're done with AAD and using an ACR access token.
        options.request.headers.set("Authorization", `Bearer ${acrAccessToken}`);
        this.cachedAcrAccessToken = acrAccessToken;
        return true;
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function toManifestWritableProperties(from) {
    // don't return unwanted properties, namely `quarantineState` and `quarantineDetails`
    return from
        ? {
            canDelete: from.canDelete,
            canList: from.canList,
            canRead: from.canRead,
            canWrite: from.canWrite,
        }
        : undefined;
}
function toArtifactManifestProperties(from, repositoryName, registryLoginServer) {
    var _a, _b, _c, _d;
    return Object.assign({ registryLoginServer,
        repositoryName, digest: from.digest, sizeInBytes: from.size, createdOn: from.createdOn, lastUpdatedOn: from.lastUpdatedOn, architecture: (_a = from.architecture) !== null && _a !== void 0 ? _a : undefined, operatingSystem: (_b = from.operatingSystem) !== null && _b !== void 0 ? _b : undefined, relatedArtifacts: (_c = from.relatedArtifacts) !== null && _c !== void 0 ? _c : [], tags: (_d = from.tags) !== null && _d !== void 0 ? _d : [] }, toManifestWritableProperties(from));
}
function toServiceTagOrderBy(orderBy) {
    return orderBy === "LastUpdatedOnAscending"
        ? "timeasc"
        : orderBy === "LastUpdatedOnDescending"
            ? "timedesc"
            : undefined;
}
function toServiceManifestOrderBy(orderBy) {
    return orderBy === "LastUpdatedOnAscending"
        ? "timeasc"
        : orderBy === "LastUpdatedOnDescending"
            ? "timedesc"
            : undefined;
}

// Copyright (c) Microsoft Corporation.
/**
 * The client class used to interact with the Container Registry service.
 * @internal
 */
class RegistryArtifactImpl {
    /**
     * Creates an instance of a RegistryArtifact.
     * @param registryEndpoint - the URL to the Container Registry endpoint
     * @param repositoryName - the name of the repository
     * @param tagOrDigest - the tag or digest of this artifact
     * @param client - the generated client that interacts with service
     */
    constructor(registryEndpoint, repositoryName, tagOrDigest, client) {
        this.tagOrDigest = tagOrDigest;
        this.registryEndpoint = registryEndpoint;
        this.repositoryName = repositoryName;
        const parsedUrl = new URL(registryEndpoint);
        if (isDigest(tagOrDigest)) {
            this.digest = tagOrDigest;
            this.fullyQualifiedReference = `${parsedUrl.hostname}/${repositoryName}@${this.digest}`;
        }
        else {
            this.fullyQualifiedReference = `${parsedUrl.hostname}/${repositoryName}:${tagOrDigest}`;
        }
        this.client = client;
    }
    /**
     * digest of this artifact.
     */
    async getDigest() {
        if (this.digest) {
            return this.digest;
        }
        if (!isDigest(this.tagOrDigest)) {
            this.digest = (await this.getTagProperties(this.tagOrDigest)).digest;
        }
        else {
            this.digest = this.tagOrDigest;
        }
        return this.digest;
    }
    /**
     * Deletes this registry artifact by deleting its manifest.
     * @param options -
     */
    async delete(options = {}) {
        return tracingClient.withSpan("RegistryArtifactImpl.delete", options, async (updatedOptions) => {
            await this.client.containerRegistry.deleteManifest(this.repositoryName, await this.getDigest(), updatedOptions);
        });
    }
    /**
     * Deletes a tag. This removes the tag from the artifact and its manifest.
     * @param tag - the name of the tag to delete.
     * @param options -
     */
    async deleteTag(tag, options = {}) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        return tracingClient.withSpan("RegistryArtifactImpl.deleteTag", options, async (updatedOptions) => {
            await this.client.containerRegistry.deleteTag(this.repositoryName, tag, updatedOptions);
        });
    }
    /**
     * Retrieves the properties of the manifest that uniquely identifies this artifact.
     * @param options -
     */
    async getManifestProperties(options = {}) {
        return tracingClient.withSpan("RegistryArtifactImpl.getManifestProperties", options, async (updatedOptions) => {
            const result = await this.client.containerRegistry.getManifestProperties(this.repositoryName, await this.getDigest(), updatedOptions);
            return toArtifactManifestProperties(result, this.repositoryName, result.registryLoginServer);
        });
    }
    /**
     * Updates the properties of the artifact's manifest.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const artifact = client.getArtifact(repositoryName, artifactTagOrDigest)
     * const updated = await artifact.updateManifestProperties({
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param options -
     */
    async updateManifestProperties(options) {
        return tracingClient.withSpan("RegistryArtifactImpl.updateManifestProperties", Object.assign(Object.assign({}, options), { value: {
                canDelete: options.canDelete,
                canWrite: options.canWrite,
                canList: options.canList,
                canRead: options.canRead,
            } }), async (updatedOptions) => {
            const result = await this.client.containerRegistry.updateManifestProperties(this.repositoryName, await this.getDigest(), updatedOptions);
            return toArtifactManifestProperties(result, this.repositoryName, result.registryLoginServer);
        });
    }
    /**
     * Retrieves the properties of the specified tag.
     * @param tag - the tag to retrieve properties.
     * @param options -
     */
    async getTagProperties(tag, options = {}) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        return tracingClient.withSpan("RegistryArtifactImpl.getTagProperties", options, (updatedOptions) => {
            return this.client.containerRegistry.getTagProperties(this.repositoryName, tag, updatedOptions);
        });
    }
    /**
     * Updates the properties of a given tag.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const artifact = client.getArtifact(repositoryName, artifactTagOrDigest)
     * const updated = await artifact.updateTagProperties(tag, {
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param tag - name of the tag to update properties on
     * @param options -
     */
    async updateTagProperties(tag, options) {
        if (!tag) {
            throw new Error("invalid tag");
        }
        return tracingClient.withSpan("RegistryArtifactImpl.updateTagProperties", Object.assign(Object.assign({}, options), { value: {
                canDelete: options.canDelete,
                canWrite: options.canWrite,
                canList: options.canList,
                canRead: options.canRead,
            } }), (updatedOptions) => {
            return this.client.containerRegistry.updateTagAttributes(this.repositoryName, tag, updatedOptions);
        });
    }
    /**
     * Returns an async iterable iterator to list the tags that uniquely identify this artifact and the properties of each.
     *
     * Example using `for-await-of` syntax:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credentials);
     * const repository = client.getRepository(repositoryName);
     * const artifact = repository.getArtifact(digest)
     * for await (const tag of artifact.listTagProperties()) {
     *   console.log("tag: ", tag);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * const iter = artifact.listTagProperties();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log("tag properties: ", item.value);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = artifact.listTagProperties().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const tagProperties of page.value) {
     *      console.log(`  repository name: ${tagProperties}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listTagProperties(options = {}) {
        const iter = this.listTagsItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listTagsPage(settings, options),
        };
    }
    listTagsItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listTagsItems_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listTagsPage({}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listTagsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listTagsPage_1() {
            const orderby = toServiceTagOrderBy(options.order);
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize, orderby });
                const currentPage = yield tslib.__await(this.client.containerRegistry.getTags(this.repositoryName, optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.tagAttributeBases) {
                    const array = currentPage.tagAttributeBases.map((t) => {
                        return Object.assign({ registryLoginServer: currentPage.registryLoginServer, repositoryName: currentPage.repository }, t);
                    });
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield tslib.__await(this.client.containerRegistry.getTagsNext(this.repositoryName, continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.tagAttributeBases) {
                    const array = currentPage.tagAttributeBases.map((t) => {
                        return Object.assign({ registryLoginServer: currentPage.registryLoginServer, repositoryName: currentPage.repository }, t);
                    });
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The client class used to interact with the Container Registry service.
 * @internal
 */
class ContainerRepositoryImpl {
    /**
     * Creates an instance of a ContainerRepository.
     * @param registryEndpoint - the URL to the Container Registry endpoint
     * @param name - the name of the repository
     * @param client - the generated client that interacts with service
     */
    constructor(registryEndpoint, name, client) {
        this.registryEndpoint = registryEndpoint;
        this.name = name;
        this.client = client;
    }
    /**
     * Deletes this repository and all artifacts that are part of its logical group.
     *
     * @param options - optional configuration for the operation
     */
    async delete(options = {}) {
        return tracingClient.withSpan("ContainerRepositoryImpl.delete", options, async (updatedOptions) => {
            await this.client.containerRegistry.deleteRepository(this.name, updatedOptions);
        });
    }
    /**
     * Returns an helper instance of {@link RegistryArtifact} for the given tag or digest.
     * @param tagOrDigest - the tag or digest of the artifact
     */
    getArtifact(tagOrDigest) {
        if (!tagOrDigest) {
            throw new Error("invalid tagOrDigest");
        }
        return new RegistryArtifactImpl(this.registryEndpoint, this.name, tagOrDigest, this.client);
    }
    /**
     * Retrieves the properties of this repository.
     * @param options -
     */
    async getProperties(options = {}) {
        return tracingClient.withSpan("ContainerRepositoryImpl.getProperties", options, (updatedOptions) => {
            return this.client.containerRegistry.getProperties(this.name, updatedOptions);
        });
    }
    /**
     * Updates the properties of this repository.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const repository = client.getRepository(repositoryName)
     * const updated = await repository.updateProperties({
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param options -
     */
    async updateProperties(options) {
        const value = {
            canDelete: options.canDelete,
            canWrite: options.canWrite,
            canList: options.canList,
            canRead: options.canRead,
        };
        return tracingClient.withSpan("ContainerRepositoryImpl.updateProperties", Object.assign(Object.assign({}, options), { value }), (updatedOptions) => {
            return this.client.containerRegistry.updateProperties(this.name, updatedOptions);
        });
    }
    /**
     * Returns an async iterable iterator to list manifest properties.
     * This is useful for determining the collection of artifacts associated with
     * this repository, as each artifact is uniquely identified by its manifest.
     *
     * Example using `for-await-of` syntax:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const repository = client.getRepository(repositoryName)
     * for await (const manifest of repository.listManifestProperties()) {
     *   console.log("manifest: ", manifest);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * const iter = repository.listManifestProperties();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log("manifest properties: ", item.value);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = repository.listManifestProperties().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const manifestProperties of page.value) {
     *      console.log(`  manifest properties: ${manifestProperties}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listManifestProperties(options = {}) {
        const iter = this.listManifestsItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listManifestsPage(settings, options),
        };
    }
    listManifestsItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listManifestsItems_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listManifestsPage({}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listManifestsPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listManifestsPage_1() {
            const orderby = toServiceManifestOrderBy(options.order);
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize, orderby });
                const currentPage = yield tslib.__await(this.client.containerRegistry.getManifests(this.name, optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.manifests) {
                    const array = currentPage.manifests.map((t) => toArtifactManifestProperties(t, this.name, currentPage.registryLoginServer));
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield tslib.__await(this.client.containerRegistry.getManifestsNext(this.name, continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.manifests) {
                    const array = currentPage.manifests.map((t) => toArtifactManifestProperties(t, this.name, currentPage.registryLoginServer));
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Base64 decode
 *
 * @internal
 * @param encodedString -
 * @returns
 */
function base64decode(encodedString) {
    return Buffer.from(encodedString, "base64").toString();
}

// Copyright (c) Microsoft Corporation.
class ContainerRegistryRefreshTokenCredential {
    constructor(authClient, authenticationScope, credential) {
        this.authenticationScope = authenticationScope;
        this.credential = credential;
        this.tokenService = new ContainerRegistryTokenService(authClient);
        this.isAnonymousAccess = !this.credential;
    }
    async getToken(_scopes, options) {
        if (!this.credential) {
            return null;
        }
        const aadToken = await this.credential.getToken(this.authenticationScope, options);
        if (!aadToken) {
            throw new Error("Failed to retrieve AAD token.");
        }
        return this.tokenService.ExchangeAadAccessTokenForAcrRefreshTokenAsync(aadToken.token, options.service, options);
    }
}
class ContainerRegistryTokenService {
    constructor(authClient) {
        this.authClient = authClient;
    }
    async ExchangeAadAccessTokenForAcrRefreshTokenAsync(aadAccessToken, service, options) {
        const acrRefreshToken = await this.authClient.authentication.exchangeAadAccessTokenForAcrRefreshToken("access_token", service, Object.assign(Object.assign({}, options), { accessToken: aadAccessToken }));
        if (!acrRefreshToken.refreshToken) {
            throw new Error("Failed to exchange AAD access token for an ACR refresh token.");
        }
        // ACR refresh token expires after three hours
        const jwtParts = acrRefreshToken.refreshToken.split(".");
        if (jwtParts.length < 3) {
            throw new Error("Invalid JWT structure from ACR refresh token.");
        }
        if (!jwtParts[1]) {
            throw new Error("Invalid JWT payload.");
        }
        const jwtPayload = JSON.parse(base64decode(jwtParts[1]));
        if (!jwtPayload.exp) {
            throw new Error("Invalid JWT payload structure. No expiration.");
        }
        // JWT expiry is in seconds
        const expiry = Number.parseInt(jwtPayload.exp) * 1000;
        return {
            token: acrRefreshToken.refreshToken,
            expiresOnTimestamp: expiry,
        };
    }
    async ExchangeAcrRefreshTokenForAcrAccessTokenAsync(acrRefreshToken, service, scope, grantType, options) {
        const acrAccessToken = await this.authClient.authentication.exchangeAcrRefreshTokenForAcrAccessToken(service, scope, acrRefreshToken, grantType, options);
        if (!acrAccessToken.accessToken) {
            throw new Error("Failed to exchange ACR refresh token for an ACR access token");
        }
        return acrAccessToken.accessToken;
    }
}

// Copyright (c) Microsoft Corporation.
const LATEST_API_VERSION$1 = "2021-07-01";
/**
 * The client class used to interact with the Container Registry service.
 */
class ContainerRegistryClient {
    constructor(endpoint, credentialOrOptions, clientOptions = {}) {
        var _a, _b;
        if (!endpoint) {
            throw new Error("invalid endpoint");
        }
        this.endpoint = endpoint;
        let credential;
        let options;
        if (coreAuth.isTokenCredential(credentialOrOptions)) {
            credential = credentialOrOptions;
            options = clientOptions;
        }
        else {
            options = credentialOrOptions !== null && credentialOrOptions !== void 0 ? credentialOrOptions : {};
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), { loggingOptions: {
                logger: logger.info,
                // This array contains header names we want to log that are not already
                // included as safe. Unknown/unsafe headers are logged as "<REDACTED>".
                additionalAllowedQueryParameters: ["last", "n", "orderby", "digest"],
            } });
        const defaultScope = `${(_a = options.audience) !== null && _a !== void 0 ? _a : "https://containerregistry.azure.net"}/.default`;
        const serviceVersion = (_b = options.serviceVersion) !== null && _b !== void 0 ? _b : LATEST_API_VERSION$1;
        const authClient = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
            credential,
            scopes: [defaultScope],
            challengeCallbacks: new ChallengeHandler(new ContainerRegistryRefreshTokenCredential(authClient, defaultScope, credential)),
        }));
    }
    /**
     * Deletes the repository identified by the given name and all associated artifacts.
     *
     * @param repositoryName - the name of repository to delete
     * @param options - optional configuration for the operation
     */
    async deleteRepository(repositoryName, options = {}) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        return tracingClient.withSpan("ContainerRegistryClient.deleteRepository", options, async (updatedOptions) => {
            await this.client.containerRegistry.deleteRepository(repositoryName, updatedOptions);
        });
    }
    /**
     * Returns an instance of {@link RegistryArtifact} for calling service methods related to the artifact specified by `repositoryName` and `tagOrDigest`.
     *
     * @param repositoryName - the name of repository
     * @param tagOrDigest - tag or digest of the artifact to retrieve
     */
    getArtifact(repositoryName, tagOrDigest) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        if (!tagOrDigest) {
            throw new Error("invalid tagOrDigest");
        }
        return new ContainerRepositoryImpl(this.endpoint, repositoryName, this.client).getArtifact(tagOrDigest);
    }
    /**
     * Returns an instance of {@link ContainerRepository} for calling service methods related to the repository specified by `repositoryName`.
     *
     * @param repositoryName - the name of repository
     */
    getRepository(repositoryName) {
        if (!repositoryName) {
            throw new Error("invalid repositoryName");
        }
        return new ContainerRepositoryImpl(this.endpoint, repositoryName, this.client);
    }
    /**
     * Returns an async iterable iterator to list names of repositories in this registry.
     *
     * Example usage:
     * ```javascript
     * let client = new ContainerRegistryClient(url, credential);
     * for await (const repository of client.listRepositoryNames()) {
     *   console.log("repository name: ", repository);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * let iter = client.listRepositoryNames();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log(`repository name: ${item.value}`);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = client.listRepositoryNames().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const name of page.value) {
     *      console.log(`  repository name: ${name}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listRepositoryNames(options = {}) {
        const iter = this.listRepositoryItems(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings = {}) => this.listRepositoriesPage(settings, options),
        };
    }
    listRepositoryItems(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRepositoryItems_1() {
            var _a, e_1, _b, _c;
            try {
                for (var _d = true, _e = tslib.__asyncValues(this.listRepositoriesPage({}, options)), _f; _f = yield tslib.__await(_e.next()), _a = _f.done, !_a;) {
                    _c = _f.value;
                    _d = false;
                    try {
                        const page = _c;
                        yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield tslib.__await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listRepositoriesPage(continuationState, options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRepositoriesPage_1() {
            if (!continuationState.continuationToken) {
                const optionsComplete = Object.assign(Object.assign({}, options), { n: continuationState.maxPageSize });
                const currentPage = yield tslib.__await(this.client.containerRegistry.getRepositories(optionsComplete));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.repositories) {
                    const array = currentPage.repositories;
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
            while (continuationState.continuationToken) {
                const currentPage = yield tslib.__await(this.client.containerRegistry.getRepositoriesNext(continuationState.continuationToken, options));
                continuationState.continuationToken = extractNextLink(currentPage.link);
                if (currentPage.repositories) {
                    const array = currentPage.repositories;
                    yield yield tslib.__await(Object.defineProperty(array, "continuationToken", {
                        value: continuationState.continuationToken,
                        enumerable: true,
                    }));
                }
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Defines known cloud audiences for Azure Container Registry.
 */
exports.KnownContainerRegistryAudience = void 0;
(function (KnownContainerRegistryAudience) {
    /** Azure China */
    KnownContainerRegistryAudience["AzureResourceManagerChina"] = "https://management.chinacloudapi.cn";
    /**
     * Azure Germany
     * @deprecated Azure Germany is being deprecated in favor of standard nonsovereign Azure regions in Germany.
     */
    KnownContainerRegistryAudience["AzureResourceManagerGermany"] = "https://management.microsoftazure.de";
    /** Azure Government */
    KnownContainerRegistryAudience["AzureResourceManagerGovernment"] = "https://management.usgovcloudapi.net";
    /** Azure Public Cloud */
    KnownContainerRegistryAudience["AzureResourceManagerPublicCloud"] = "https://management.azure.com";
})(exports.KnownContainerRegistryAudience || (exports.KnownContainerRegistryAudience = {}));
/**
 * Defines known artifact architectures that the service supports.
 */
exports.KnownArtifactArchitecture = void 0;
(function (KnownArtifactArchitecture) {
    /** i386 */
    KnownArtifactArchitecture["I386"] = "386";
    /** AMD64 */
    KnownArtifactArchitecture["Amd64"] = "amd64";
    /** ARM */
    KnownArtifactArchitecture["Arm"] = "arm";
    /** ARM64 */
    KnownArtifactArchitecture["Arm64"] = "arm64";
    /** MIPS */
    KnownArtifactArchitecture["Mips"] = "mips";
    /** MIPSLE */
    KnownArtifactArchitecture["MipsLe"] = "mipsle";
    /** MIPS64 */
    KnownArtifactArchitecture["Mips64"] = "mips64";
    /** MIPS64LE */
    KnownArtifactArchitecture["Mips64Le"] = "mips64le";
    /** PPC64 */
    KnownArtifactArchitecture["Ppc64"] = "ppc64";
    /** PPC64LE */
    KnownArtifactArchitecture["Ppc64Le"] = "ppc64le";
    /** RISCv64 */
    KnownArtifactArchitecture["RiscV64"] = "riscv64";
    /** s390x */
    KnownArtifactArchitecture["S390X"] = "s390x";
    /** Wasm */
    KnownArtifactArchitecture["Wasm"] = "wasm";
})(exports.KnownArtifactArchitecture || (exports.KnownArtifactArchitecture = {}));
/**
 * Defines known artifact platform's operating systems that the service supports.
 */
exports.KnownArtifactOperatingSystem = void 0;
(function (KnownArtifactOperatingSystem) {
    /** Aix */
    KnownArtifactOperatingSystem["Aix"] = "aix";
    /** Android */
    KnownArtifactOperatingSystem["Android"] = "android";
    /** Darwin */
    KnownArtifactOperatingSystem["Darwin"] = "darwin";
    /** Dragonfly */
    KnownArtifactOperatingSystem["Dragonfly"] = "dragonfly";
    /** FreeBSD */
    KnownArtifactOperatingSystem["FreeBsd"] = "freebsd";
    /** Illumos */
    KnownArtifactOperatingSystem["Illumos"] = "illumos";
    /** iOS */
    KnownArtifactOperatingSystem["iOS"] = "ios";
    /** JS */
    KnownArtifactOperatingSystem["JS"] = "js";
    /** Linux */
    KnownArtifactOperatingSystem["Linux"] = "linux";
    /** NetBSD */
    KnownArtifactOperatingSystem["NetBsd"] = "netbsd";
    /** OpenBSD */
    KnownArtifactOperatingSystem["OpenBsd"] = "openbsd";
    /** Plan9 */
    KnownArtifactOperatingSystem["Plan9"] = "plan9";
    /** Solaris */
    KnownArtifactOperatingSystem["Solaris"] = "solaris";
    /** Windows */
    KnownArtifactOperatingSystem["Windows"] = "windows";
})(exports.KnownArtifactOperatingSystem || (exports.KnownArtifactOperatingSystem = {}));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/**
 * Known media type values for Docker and OCI manifests.
 */
exports.KnownManifestMediaType = void 0;
(function (KnownManifestMediaType) {
    /**
     * The media type for an OCI image manifest. This format is described at https://github.com/opencontainers/image-spec/blob/main/manifest.md.
     */
    KnownManifestMediaType["OciImageManifest"] = "application/vnd.oci.image.manifest.v1+json";
    /**
     * The media type for a Docker Image Manifest, Version 2, Schema 2. This format is described at https://docs.docker.com/registry/spec/manifest-v2-2/.
     */
    KnownManifestMediaType["DockerManifest"] = "application/vnd.docker.distribution.manifest.v2+json";
})(exports.KnownManifestMediaType || (exports.KnownManifestMediaType = {}));

// Copyright (c) Microsoft Corporation.
function calculateDigest(bufferOrStream) {
    const hash = crypto__default["default"].createHash("sha256");
    if (Buffer.isBuffer(bufferOrStream)) {
        return Promise.resolve(`sha256:${hash.update(bufferOrStream).digest("hex")}`);
    }
    else {
        bufferOrStream.pipe(hash);
        return new Promise((resolve, reject) => {
            bufferOrStream.on("end", () => {
                hash.end();
                resolve(`sha256:${hash.digest("hex")}`);
            });
            bufferOrStream.on("error", (err) => reject(err));
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * ONLY AVAILABLE IN NODE.JS RUNTIME.
 *
 * A Node.js ReadableStream will internally retry when internal ReadableStream unexpected ends.
 */
class RetriableReadableStream extends stream.Readable {
    /**
     * Creates an instance of RetriableReadableStream.
     *
     * @param source - The current ReadableStream returned from getter
     * @param getter - A method calling downloading request returning
     *                                      a new ReadableStream from specified offset
     * @param offset - Offset position in original data source to read
     * @param count - How much data in original data source to read
     * @param options -
     */
    constructor(source, getter, offset, count, options = {}) {
        super({ highWaterMark: options.highWaterMark });
        this.source = source;
        this.getter = getter;
        this.offset = offset;
        this.retries = 0;
        this.sourceDataHandler = (data) => {
            var _a, _b;
            if (this.options.doInjectErrorOnce) {
                this.options.doInjectErrorOnce = undefined;
                this.source.pause();
                this.sourceErrorOrEndHandler();
                this.source.destroy();
                return;
            }
            this.offset += data.length;
            if (this.offset > this.end + 1) {
                this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
            }
            (_a = this.onData) === null || _a === void 0 ? void 0 : _a.call(this, data);
            (_b = this.onProgress) === null || _b === void 0 ? void 0 : _b.call(this, { loadedBytes: this.offset - this.start });
            if (!this.push(data)) {
                this.source.pause();
            }
        };
        this.sourceAbortedHandler = () => {
            const abortError = new abortController.AbortError("The operation was aborted.");
            this.destroy(abortError);
        };
        this.sourceErrorOrEndHandler = (err) => {
            var _a;
            if (err && err.name === "AbortError") {
                this.destroy(err);
                return;
            }
            this.removeSourceEventHandlers();
            if (this.offset - 1 === this.end) {
                (_a = this.onEnd) === null || _a === void 0 ? void 0 : _a.call(this);
                this.push(null);
            }
            else if (this.offset <= this.end) {
                if (this.retries < this.maxRetryRequests) {
                    this.retries += 1;
                    this.getter(this.offset)
                        .then((newSource) => {
                        this.source = newSource;
                        this.setSourceEventHandlers();
                        return;
                    })
                        .catch((error) => {
                        this.destroy(error);
                    });
                }
                else {
                    this.destroy(new Error(`Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`));
                }
            }
            else {
                this.destroy(new Error(`Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`));
            }
        };
        this.getter = getter;
        this.start = offset;
        this.end = offset + count - 1;
        this.maxRetryRequests =
            options.maxRetryRequests && options.maxRetryRequests >= 0 ? options.maxRetryRequests : 0;
        this.onData = options.onData;
        this.onEnd = options.onEnd;
        this.onProgress = options.onProgress;
        this.options = options;
        this.setSourceEventHandlers();
    }
    _read() {
        this.source.resume();
    }
    setSourceEventHandlers() {
        this.source.on("data", this.sourceDataHandler);
        this.source.on("end", this.sourceErrorOrEndHandler);
        this.source.on("error", this.sourceErrorOrEndHandler);
        // needed for Node14
        this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
        this.source.removeListener("data", this.sourceDataHandler);
        this.source.removeListener("end", this.sourceErrorOrEndHandler);
        this.source.removeListener("error", this.sourceErrorOrEndHandler);
        this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    _destroy(error, callback) {
        // remove listener from source and release source
        this.removeSourceEventHandlers();
        this.source.destroy();
        callback(error === null ? undefined : error);
    }
}

// Copyright (c) Microsoft Corporation.
const LATEST_API_VERSION = "2021-07-01";
const CHUNK_SIZE = 4 * 1024 * 1024; // 4 MB
const MAX_MANIFEST_SIZE_BYTES = 4 * 1024 * 1024; // 4 MB
const ACCEPTED_MANIFEST_MEDIA_TYPES = [
    exports.KnownManifestMediaType.OciImageManifest,
    exports.KnownManifestMediaType.DockerManifest,
    "application/vnd.oci.image.index.v1+json",
    "application/vnd.docker.distribution.manifest.list.v2+json",
    "application/vnd.docker.container.image.v1+json",
];
function isReadableStream(body) {
    return body && typeof body.pipe === "function";
}
function assertHasProperty(obj, property) {
    if (!Object.prototype.hasOwnProperty.call(obj, property)) {
        throw new coreRestPipeline.RestError(`Expected property ${String(property)} to be defined.`);
    }
}
/**
 * Error thrown when the Docker content digest returned from the
 * server does not match the digest calculated from the content.
 */
class DigestMismatchError extends Error {
    constructor(message) {
        super(message);
        this.name = "DigestMismatchError";
    }
}
/**
 * The Azure Container Registry blob client, responsible for uploading and downloading blobs and manifests, the building blocks of artifacts.
 */
class ContainerRegistryContentClient {
    /**
     * Creates an instance of a ContainerRegistryContentClient for managing container images and artifacts.
     *
     * Example usage:
     * ```ts
     * import { ContainerRegistryContentClient } from "@azure/container-registry";
     * import { DefaultAzureCredential} from "@azure/identity";
     *
     * const client = new ContainerRegistryContentClient(
     *    "<container registry API endpoint>",
     *    "<repository name>",
     *    new DefaultAzureCredential()
     * );
     * ```
     * @param endpoint - the URL endpoint of the container registry
     * @param repositoryName - the name of the repository that logically groups the artifact parts
     * @param credential - used to authenticate requests to the service
     * @param options - optional configuration used to send requests to the service
     */
    constructor(endpoint, repositoryName, credential, options = {}) {
        var _a, _b;
        if (!endpoint) {
            throw new Error("invalid endpoint");
        }
        this.endpoint = endpoint;
        this.repositoryName = repositoryName;
        const internalPipelineOptions = Object.assign(Object.assign({}, options), { loggingOptions: {
                logger: logger.info,
                // This array contains header names we want to log that are not already
                // included as safe. Unknown/unsafe headers are logged as "<REDACTED>".
                additionalAllowedQueryParameters: [
                    "last",
                    "n",
                    "orderby",
                    "digest",
                    "_nouploadcache",
                    "_state",
                ],
            } });
        const defaultScope = `${(_a = options.audience) !== null && _a !== void 0 ? _a : "https://containerregistry.azure.net"}/.default`;
        const serviceVersion = (_b = options.serviceVersion) !== null && _b !== void 0 ? _b : LATEST_API_VERSION;
        const authClient = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client = new GeneratedClient(endpoint, serviceVersion, internalPipelineOptions);
        this.client.pipeline.addPolicy(coreRestPipeline.bearerTokenAuthenticationPolicy({
            credential,
            scopes: [defaultScope],
            challengeCallbacks: new ChallengeHandler(new ContainerRegistryRefreshTokenCredential(authClient, defaultScope, credential)),
        }));
    }
    /**
     * Delete a blob.
     * @param digest - the digest of the blob to delete
     * @param options - optional configuration used to send requests to the service
     */
    async deleteBlob(digest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.deleteBlob", options, async (updatedOptions) => {
            await this.client.containerRegistryBlob.deleteBlob(this.repositoryName, digest, updatedOptions);
        });
    }
    /**
     * Upload a manifest for an OCI artifact.
     *
     * @param manifest - the manifest to upload.
     */
    async setManifest(manifest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.uploadManifest", options, async (updatedOptions) => {
            var _a;
            let manifestBody;
            let tagOrDigest = options === null || options === void 0 ? void 0 : options.tag;
            if (Buffer.isBuffer(manifest)) {
                manifestBody = manifest;
                tagOrDigest !== null && tagOrDigest !== void 0 ? tagOrDigest : (tagOrDigest = await calculateDigest(manifest));
            }
            else if (isReadableStream(manifest)) {
                manifestBody = await readStreamToEnd(manifest);
                tagOrDigest !== null && tagOrDigest !== void 0 ? tagOrDigest : (tagOrDigest = await calculateDigest(manifestBody));
            }
            else {
                manifestBody = Buffer.from(JSON.stringify(manifest));
                tagOrDigest !== null && tagOrDigest !== void 0 ? tagOrDigest : (tagOrDigest = await calculateDigest(manifestBody));
            }
            const createManifestResult = await this.client.containerRegistry.createManifest(this.repositoryName, tagOrDigest, manifestBody, Object.assign({ contentType: (_a = options === null || options === void 0 ? void 0 : options.mediaType) !== null && _a !== void 0 ? _a : exports.KnownManifestMediaType.OciImageManifest }, updatedOptions));
            assertHasProperty(createManifestResult, "dockerContentDigest");
            return { digest: createManifestResult.dockerContentDigest };
        });
    }
    /**
     * Downloads the manifest for an OCI artifact.
     *
     * @param tagOrDigest - a tag or digest that identifies the artifact
     * @returns - the downloaded manifest.
     */
    async getManifest(tagOrDigest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.downloadManifest", options, async (updatedOptions) => {
            const response = await this.client.containerRegistry.getManifest(this.repositoryName, tagOrDigest, Object.assign({ accept: ACCEPTED_MANIFEST_MEDIA_TYPES.join(", ") }, updatedOptions));
            assertHasProperty(response, "mediaType");
            const content = response.readableStreamBody
                ? await readStreamToEnd(response.readableStreamBody, MAX_MANIFEST_SIZE_BYTES)
                : Buffer.alloc(0);
            const expectedDigest = await calculateDigest(content);
            if (isDigest(tagOrDigest) && expectedDigest !== tagOrDigest) {
                throw new DigestMismatchError("Digest of downloaded manifest does not match the input digest");
            }
            if (response.dockerContentDigest !== expectedDigest) {
                throw new DigestMismatchError("Computed digest of downloaded manifest does not match the value of the Docker-Content-Digest header");
            }
            return {
                digest: response.dockerContentDigest,
                mediaType: response.mediaType,
                content,
                manifest: JSON.parse(content.toString("utf-8")),
            };
        });
    }
    /**
     * Delete a manifest. Doing so effectively deletes an artifact from the registry.
     *
     * @param digest - the digest of the manifest to delete
     * @param options - optional configuration used to send requests to the service
     */
    async deleteManifest(digest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.deleteManifest", options, async (updatedOptions) => {
            await this.client.containerRegistry.deleteManifest(this.repositoryName, digest, updatedOptions);
        });
    }
    /**
     * Upload an artifact blob.
     *
     * @param blobStream - the stream containing the blob data.
     */
    async uploadBlob(blob, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.uploadBlob", options, async (updatedOptions) => {
            var _a, e_1, _b, _c;
            const blobStream = Buffer.isBuffer(blob) ? stream.Readable.from(blob) : blob;
            const startUploadResult = await this.client.containerRegistryBlob.startUpload(this.repositoryName, updatedOptions);
            assertHasProperty(startUploadResult, "location");
            let location = startUploadResult.location.substring(1);
            const chunks = readChunksFromStream(blobStream, CHUNK_SIZE);
            const hash = crypto__default["default"].createHash("sha256");
            let bytesUploaded = 0;
            try {
                for (var _d = true, chunks_1 = tslib.__asyncValues(chunks), chunks_1_1; chunks_1_1 = await chunks_1.next(), _a = chunks_1_1.done, !_a;) {
                    _c = chunks_1_1.value;
                    _d = false;
                    try {
                        const chunk = _c;
                        hash.write(chunk);
                        const result = await this.client.containerRegistryBlob.uploadChunk(location, chunk, updatedOptions);
                        bytesUploaded += chunk.byteLength;
                        assertHasProperty(result, "location");
                        location = result.location.substring(1);
                    }
                    finally {
                        _d = true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = chunks_1.return)) await _b.call(chunks_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            hash.end();
            const digest = `sha256:${hash.digest("hex")}`;
            const { dockerContentDigest: digestFromResponse } = await this.client.containerRegistryBlob.completeUpload(digest, location, updatedOptions);
            if (digest !== digestFromResponse) {
                throw new DigestMismatchError("Digest of blob to upload does not match the digest from the server.");
            }
            return { digest, sizeInBytes: bytesUploaded };
        });
    }
    /**
     * Download a blob that is part of an artifact.
     *
     * @param digest - the digest of the blob to download
     * @param options - optional configuration used to send requests to the service
     * @returns - the downloaded blob
     */
    async downloadBlob(digest, options = {}) {
        return tracingClient.withSpan("ContainerRegistryContentClient.downloadBlob", options, async (updatedOptions) => {
            const initialResponse = await this.client.containerRegistryBlob.getBlob(this.repositoryName, digest, updatedOptions);
            assertHasProperty(initialResponse, "readableStreamBody");
            assertHasProperty(initialResponse, "contentLength");
            const hash = crypto__default["default"].createHash("sha256");
            return {
                digest,
                content: new RetriableReadableStream(initialResponse.readableStreamBody, async (pos) => {
                    const retryResponse = await this.client.containerRegistryBlob.getChunk(this.repositoryName, digest, `${pos}-`, updatedOptions);
                    assertHasProperty(retryResponse, "readableStreamBody");
                    return retryResponse.readableStreamBody;
                }, 0, initialResponse.contentLength, {
                    onData: (data) => hash.write(data),
                    onEnd: () => {
                        hash.end();
                        const calculatedDigest = `sha256:${hash.digest("hex")}`;
                        if (digest !== calculatedDigest) {
                            throw new DigestMismatchError("Digest calculated from downloaded blob content does not match digest requested.");
                        }
                    },
                }),
            };
        });
    }
}

exports.ContainerRegistryClient = ContainerRegistryClient;
exports.ContainerRegistryContentClient = ContainerRegistryContentClient;
exports.DigestMismatchError = DigestMismatchError;
//# sourceMappingURL=index.js.map
