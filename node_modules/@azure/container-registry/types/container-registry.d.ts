/// <reference types="node" />
/// <reference lib="esnext.asynciterable" />

import { CommonClientOptions } from '@azure/core-client';
import { OperationOptions } from '@azure/core-client';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { TokenCredential } from '@azure/core-auth';

/**
 * Defines values for ArtifactManifestOrder.
 *  this contains the known values that the service supports.
 * ### Know values supported by the service
 * **LastUpdatedOnDescending**: Order registry artifacts by LastUpdatedOn field, from most recently updated to least recently updated.
 * **LastUpdatedOnAscending**: Order  registry artifacts by LastUpdatedOn field, from least recently updated to most recently updated.
 */
export declare type ArtifactManifestOrder = "LastUpdatedOnDescending" | "LastUpdatedOnAscending";

/** Manifest attributes details */
export declare interface ArtifactManifestPlatform {
    /**
     * Manifest digest
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly digest: string;
    /**
     * CPU architecture. See {@link KnownArtifactArchitecture} for values supported by the service.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly architecture?: string;
    /**
     * Operating system. See {@link KnownArtifactOperatingSystem} for values supported by the service.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly operatingSystem?: string;
}

/** Manifest attributes details */
export declare interface ArtifactManifestProperties {
    /**
     * Registry login server name.  This is likely to be similar to <registry-name>.azurecr.io
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly registryLoginServer: string;
    /**
     * Repository name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly repositoryName: string;
    /**
     * Manifest
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly digest: string;
    /**
     * Image size
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly sizeInBytes?: number;
    /**
     * Created time
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly createdOn: Date;
    /**
     * Last update time
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly lastUpdatedOn: Date;
    /**
     * CPU architecture. See {@link KnownArtifactArchitecture} for values supported by the service.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly architecture?: string;
    /**
     * Operating system. See {@link KnownArtifactOperatingSystem} for values supported by the service.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly operatingSystem?: string;
    /**
     * List of manifests referenced by this manifest list.  List will be empty if this manifest is not a manifest list.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly relatedArtifacts: ArtifactManifestPlatform[];
    /**
     * List of tags
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly tags: string[];
    /** Delete enabled */
    canDelete?: boolean;
    /** Write enabled */
    canWrite?: boolean;
    /** List enabled */
    canList?: boolean;
    /** Read enabled */
    canRead?: boolean;
}

/**
 * Defines values for ArtifactTagOrder.
 *  this contains the known values that the service supports.
 * ### Know values supported by the service
 * **LastUpdatedOnDescending**: Order tags by LastUpdatedOn field, from most recently updated to least recently updated.
 * **LastUpdatedOnAscending**: Order tags by LastUpdatedOn field, from least recently updated to most recently updated.
 */
export declare type ArtifactTagOrder = "LastUpdatedOnDescending" | "LastUpdatedOnAscending";

/** Tag attributes */
export declare interface ArtifactTagProperties {
    /**
     * Registry login server name. This is likely to be similar to {registry-name}.azurecr.io.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly registryLoginServer: string;
    /**
     * Image name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly repositoryName: string;
    /**
     * Tag name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name: string;
    /**
     * Tag digest
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly digest: string;
    /**
     * Tag created time
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly createdOn: Date;
    /**
     * Tag last update time
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly lastUpdatedOn: Date;
    /** Delete enabled */
    canDelete?: boolean;
    /** Write enabled */
    canWrite?: boolean;
    /** List enabled */
    canList?: boolean;
    /** Read enabled */
    canRead?: boolean;
}

/**
 * The client class used to interact with the Container Registry service.
 */
export declare class ContainerRegistryClient {
    /**
     * The Azure Container Registry endpoint.
     */
    readonly endpoint: string;
    private client;
    /**
     * Creates an instance of a ContainerRegistryClient.
     *
     * Example usage:
     * ```ts
     * import { ContainerRegistryClient } from "@azure/container-registry";
     * import { DefaultAzureCredential} from "@azure/identity";
     *
     * const client = new ContainerRegistryClient(
     *    "<container registry API endpoint>",
     *    new DefaultAzureCredential()
     * );
     * ```
     * @param endpoint - the URL endpoint of the container registry
     * @param credential - used to authenticate requests to the service
     * @param options - optional configuration used to send requests to the service
     */
    constructor(endpoint: string, credential: TokenCredential, options?: ContainerRegistryClientOptions);
    /**
     * Creates an instance of a ContainerRegistryClient to interact with
     * an Azure Container Registry that has anonymous pull access enabled.
     * Only operations that support anonymous access are enabled. Other service
     * methods will throw errors.
     *
     * Example usage:
     * ```ts
     * import { ContainerRegistryClient } from "@azure/container-registry";
     *
     * const client = new ContainerRegistryClient(
     *    "<container registry API endpoint>",
     * );
     * ```
     * @param endpoint - the URL endpoint of the container registry
     * @param options - optional configuration used to send requests to the service
     */
    constructor(endpoint: string, options?: ContainerRegistryClientOptions);
    /**
     * Deletes the repository identified by the given name and all associated artifacts.
     *
     * @param repositoryName - the name of repository to delete
     * @param options - optional configuration for the operation
     */
    deleteRepository(repositoryName: string, options?: DeleteRepositoryOptions): Promise<void>;
    /**
     * Returns an instance of {@link RegistryArtifact} for calling service methods related to the artifact specified by `repositoryName` and `tagOrDigest`.
     *
     * @param repositoryName - the name of repository
     * @param tagOrDigest - tag or digest of the artifact to retrieve
     */
    getArtifact(repositoryName: string, tagOrDigest: string): RegistryArtifact;
    /**
     * Returns an instance of {@link ContainerRepository} for calling service methods related to the repository specified by `repositoryName`.
     *
     * @param repositoryName - the name of repository
     */
    getRepository(repositoryName: string): ContainerRepository;
    /**
     * Returns an async iterable iterator to list names of repositories in this registry.
     *
     * Example usage:
     * ```javascript
     * let client = new ContainerRegistryClient(url, credential);
     * for await (const repository of client.listRepositoryNames()) {
     *   console.log("repository name: ", repository);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * let iter = client.listRepositoryNames();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log(`repository name: ${item.value}`);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = client.listRepositoryNames().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const name of page.value) {
     *      console.log(`  repository name: ${name}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listRepositoryNames(options?: ListRepositoriesOptions): PagedAsyncIterableIterator<string, RepositoryPageResponse>;
    private listRepositoryItems;
    private listRepositoriesPage;
}

/**
 * Client options used to configure Container Registry Repository API requests.
 */
export declare interface ContainerRegistryClientOptions extends CommonClientOptions {
    /**
     * Gets or sets the audience to use for authentication with Azure Active Directory.
     * The authentication scope will be set from this audience.
     * See {@link KnownContainerRegistryAudience} for known audience values.
     */
    audience?: string;
    /**
     * The version of service API to make calls against.
     */
    serviceVersion?: "2021-07-01";
}

/**
 * The Azure Container Registry blob client, responsible for uploading and downloading blobs and manifests, the building blocks of artifacts.
 */
export declare class ContainerRegistryContentClient {
    /**
     * The Azure Container Registry endpoint.
     */
    readonly endpoint: string;
    /**
     * The name of the repository that logically groups the artifact parts.
     */
    readonly repositoryName: string;
    private client;
    /**
     * Creates an instance of a ContainerRegistryContentClient for managing container images and artifacts.
     *
     * Example usage:
     * ```ts
     * import { ContainerRegistryContentClient } from "@azure/container-registry";
     * import { DefaultAzureCredential} from "@azure/identity";
     *
     * const client = new ContainerRegistryContentClient(
     *    "<container registry API endpoint>",
     *    "<repository name>",
     *    new DefaultAzureCredential()
     * );
     * ```
     * @param endpoint - the URL endpoint of the container registry
     * @param repositoryName - the name of the repository that logically groups the artifact parts
     * @param credential - used to authenticate requests to the service
     * @param options - optional configuration used to send requests to the service
     */
    constructor(endpoint: string, repositoryName: string, credential: TokenCredential, options?: ContainerRegistryContentClientOptions);
    /**
     * Delete a blob.
     * @param digest - the digest of the blob to delete
     * @param options - optional configuration used to send requests to the service
     */
    deleteBlob(digest: string, options?: DeleteBlobOptions): Promise<void>;
    /**
     * Upload a manifest for an OCI artifact.
     *
     * @param manifest - the manifest to upload.
     */
    setManifest(manifest: Buffer | NodeJS.ReadableStream | OciImageManifest | Record<string, unknown>, options?: SetManifestOptions): Promise<SetManifestResult>;
    /**
     * Downloads the manifest for an OCI artifact.
     *
     * @param tagOrDigest - a tag or digest that identifies the artifact
     * @returns - the downloaded manifest.
     */
    getManifest(tagOrDigest: string, options?: GetManifestOptions): Promise<GetManifestResult>;
    /**
     * Delete a manifest. Doing so effectively deletes an artifact from the registry.
     *
     * @param digest - the digest of the manifest to delete
     * @param options - optional configuration used to send requests to the service
     */
    deleteManifest(digest: string, options?: DeleteManifestOptions): Promise<void>;
    /**
     * Upload an artifact blob.
     *
     * @param blobStream - the stream containing the blob data.
     */
    uploadBlob(blob: NodeJS.ReadableStream | Buffer, options?: UploadBlobOptions): Promise<UploadBlobResult>;
    /**
     * Download a blob that is part of an artifact.
     *
     * @param digest - the digest of the blob to download
     * @param options - optional configuration used to send requests to the service
     * @returns - the downloaded blob
     */
    downloadBlob(digest: string, options?: DownloadBlobOptions): Promise<DownloadBlobResult>;
}

/**
 * Client options used to configure Container Registry Blob API requests.
 */
export declare interface ContainerRegistryContentClientOptions extends CommonClientOptions {
    /**
     * Gets or sets the audience to use for authentication with Azure Active Directory.
     * The authentication scope will be set from this audience.
     * See {@link KnownContainerRegistryAudience} for known audience values.
     */
    audience?: string;
    /**
     * The version of service API to make calls against.
     */
    serviceVersion?: "2021-07-01";
}

/**
 * A `repository` in a container registry is a logical grouping of images or artifacts that share the same name.  For example,
 * different versions of a `hello-world` application could have tags `v1` and `v2`, and be grouped by the repository `hello-world`.
 *
 * The {@link ContainerRepository} interface is a helper that groups information and operations about a repository in this
 * container registry.
 */
export declare interface ContainerRepository {
    /**
     * The Azure Container Registry endpoint.
     */
    readonly registryEndpoint: string;
    /**
     * Repository name.
     */
    readonly name: string;
    /**
     * Deletes this repository and all artifacts that are part of its logical group.
     *
     * @param options - optional configuration for the operation
     */
    delete(options?: DeleteRepositoryOptions): Promise<void>;
    /**
     * Returns an helper instance of {@link RegistryArtifact} for the given tag or digest.
     * @param tagOrDigest - the tag or digest of the artifact
     */
    getArtifact(tagOrDigest: string): RegistryArtifact;
    /**
     * Retrieves the properties of this repository.
     * @param options -
     */
    getProperties(options?: GetRepositoryPropertiesOptions): Promise<ContainerRepositoryProperties>;
    /**
     * Updates the properties of this repository.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const repository = client.getRepository(repositoryName)
     * const updated = await repository.updateProperties({
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param options -
     */
    updateProperties(options: UpdateRepositoryPropertiesOptions): Promise<ContainerRepositoryProperties>;
    /**
     * Returns an async iterable iterator to list manifest properties.
     * This is useful for determining the collection of artifacts associated with
     * this repository, as each artifact is uniquely identified by its manifest.
     *
     * Example using `for-await-of` syntax:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const repository = client.getRepository(repositoryName)
     * for await (const manifest of repository.listManifestProperties()) {
     *   console.log("manifest: ", manifest);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * const iter = repository.listManifestProperties();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log("manifest properties: ", item.value);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = repository.listManifestProperties().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const manifestProperties of page.value) {
     *      console.log(`  manifest properties: ${manifestProperties}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listManifestProperties(options?: ListManifestPropertiesOptions): PagedAsyncIterableIterator<ArtifactManifestProperties>;
}

/** Properties of this repository. */
export declare interface ContainerRepositoryProperties {
    /**
     * Registry login server name. This is likely to be similar to {registry-name}.azurecr.io.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly registryLoginServer: string;
    /**
     * Image name
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly name: string;
    /**
     * Image created time
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly createdOn: Date;
    /**
     * Image last update time
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly lastUpdatedOn: Date;
    /**
     * Number of the manifests
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly manifestCount: number;
    /**
     * Number of the tags
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly tagCount: number;
    /** Delete enabled */
    canDelete?: boolean;
    /** Write enabled */
    canWrite?: boolean;
    /** List enabled */
    canList?: boolean;
    /** Read enabled */
    canRead?: boolean;
}

/**
 * Options for the `delete` method of `RegistryArtifact`.
 */
export declare interface DeleteArtifactOptions extends OperationOptions {
}

/**
 * Options for confguring the delete blob operation.
 */
export declare interface DeleteBlobOptions extends OperationOptions {
}

/**
 * Options for confguring the delete manifest operation.
 */
export declare interface DeleteManifestOptions extends OperationOptions {
}

/**
 * Options for delete repository operation.
 */
export declare interface DeleteRepositoryOptions extends OperationOptions {
}

/**
 * Options for the `deleteTag` method of `RegistryArtifact`.
 */
export declare interface DeleteTagOptions extends OperationOptions {
}

/**
 * Error thrown when the Docker content digest returned from the
 * server does not match the digest calculated from the content.
 */
export declare class DigestMismatchError extends Error {
    constructor(message: string);
}

/**
 * Options for confguring the download blob operation.
 */
export declare interface DownloadBlobOptions extends OperationOptions {
}

/**
 * The result from downloading a blob from the registry.
 */
export declare interface DownloadBlobResult {
    /**
     * The blob's digest, calculated by the resgistry.
     */
    digest: string;
    /**
     * The blob content.
     */
    content: NodeJS.ReadableStream;
}

/**
 * Options for confguring the download manifest operation.
 */
export declare interface GetManifestOptions extends OperationOptions {
}

/**
 * Options for the `getManifestProperties` method of `RegistryArtifact`.
 */
export declare interface GetManifestPropertiesOptions extends OperationOptions {
}

/**
 * The result from downloading a manifest from the registry.
 */
export declare interface GetManifestResult {
    /**
     * The digest of the downloaded manifest as calculated by the registry.
     */
    digest: string;
    /**
     * Media type of the downloaded manifest as indicated by the Content-Type response header.
     */
    mediaType: string;
    /**
     * The raw content of the manifest that was downloaded.
     */
    content: Buffer;
    /**
     * The deserialized manifest
     */
    manifest: Record<string, unknown>;
}

/**
 * Options for the `getProperties` method of `ContainerRepository`.
 */
export declare interface GetRepositoryPropertiesOptions extends OperationOptions {
}

/**
 * Options for the `getTagProperties` method of `RegistryArtifact`.
 */
export declare interface GetTagPropertiesOptions extends OperationOptions {
}

/**
 * Defines known artifact architectures that the service supports.
 */
export declare enum KnownArtifactArchitecture {
    /** i386 */
    I386 = "386",
    /** AMD64 */
    Amd64 = "amd64",
    /** ARM */
    Arm = "arm",
    /** ARM64 */
    Arm64 = "arm64",
    /** MIPS */
    Mips = "mips",
    /** MIPSLE */
    MipsLe = "mipsle",
    /** MIPS64 */
    Mips64 = "mips64",
    /** MIPS64LE */
    Mips64Le = "mips64le",
    /** PPC64 */
    Ppc64 = "ppc64",
    /** PPC64LE */
    Ppc64Le = "ppc64le",
    /** RISCv64 */
    RiscV64 = "riscv64",
    /** s390x */
    S390X = "s390x",
    /** Wasm */
    Wasm = "wasm"
}

/**
 * Defines known artifact platform's operating systems that the service supports.
 */
export declare enum KnownArtifactOperatingSystem {
    /** Aix */
    Aix = "aix",
    /** Android */
    Android = "android",
    /** Darwin */
    Darwin = "darwin",
    /** Dragonfly */
    Dragonfly = "dragonfly",
    /** FreeBSD */
    FreeBsd = "freebsd",
    /** Illumos */
    Illumos = "illumos",
    /** iOS */
    iOS = "ios",
    /** JS */
    JS = "js",
    /** Linux */
    Linux = "linux",
    /** NetBSD */
    NetBsd = "netbsd",
    /** OpenBSD */
    OpenBsd = "openbsd",
    /** Plan9 */
    Plan9 = "plan9",
    /** Solaris */
    Solaris = "solaris",
    /** Windows */
    Windows = "windows"
}

/**
 * Defines known cloud audiences for Azure Container Registry.
 */
export declare enum KnownContainerRegistryAudience {
    /** Azure China */
    AzureResourceManagerChina = "https://management.chinacloudapi.cn",
    /**
     * Azure Germany
     * @deprecated Azure Germany is being deprecated in favor of standard nonsovereign Azure regions in Germany.
     */
    AzureResourceManagerGermany = "https://management.microsoftazure.de",
    /** Azure Government */
    AzureResourceManagerGovernment = "https://management.usgovcloudapi.net",
    /** Azure Public Cloud */
    AzureResourceManagerPublicCloud = "https://management.azure.com"
}

/**
 * Known media type values for Docker and OCI manifests.
 */
export declare enum KnownManifestMediaType {
    /**
     * The media type for an OCI image manifest. This format is described at https://github.com/opencontainers/image-spec/blob/main/manifest.md.
     */
    OciImageManifest = "application/vnd.oci.image.manifest.v1+json",
    /**
     * The media type for a Docker Image Manifest, Version 2, Schema 2. This format is described at https://docs.docker.com/registry/spec/manifest-v2-2/.
     */
    DockerManifest = "application/vnd.docker.distribution.manifest.v2+json"
}

/**
 * Options for the `listRegistryArtifacts` method of `ContainerRepository`.
 */
export declare interface ListManifestPropertiesOptions extends OperationOptions {
    /** order in which the manifest properties are returned */
    order?: ArtifactManifestOrder;
}

/**
 * Options for the `listRepositories` method of `ContainerRegistryClient`.
 */
export declare interface ListRepositoriesOptions extends OperationOptions {
}

/**
 * Options for the `listTagProperties` method of `RegistryArtifact`.
 */
export declare interface ListTagPropertiesOptions extends OperationOptions {
    /** order in which the tags are returned */
    order?: ArtifactTagOrder;
}

/**
 * Contains response data for the listManifests operation.
 */
export declare interface ManifestPageResponse extends Array<ArtifactManifestProperties> {
    /**
     * Continuation token to pass to `byPage()` to resume listing of more results if available.
     */
    continuationToken?: string;
}

/** Additional information provided through arbitrary metadata.
 * See the specification at https://github.com/opencontainers/image-spec/blob/main/annotations.md for more information.
 */
export declare interface OciAnnotations extends Record<string, unknown> {
    /** Date and time on which the image was built (string, date-time as defined by https://tools.ietf.org/html/rfc3339#section-5.6) */
    "org.opencontainers.image.created"?: string;
    /** Contact details of the people or organization responsible for the image. */
    "org.opencontainers.image.authors"?: string;
    /** URL to find more information on the image. */
    "org.opencontainers.image.url"?: string;
    /** URL to get documentation on the image. */
    "org.opencontainers.image.documentation"?: string;
    /** URL to get source code for building the image. */
    "org.opencontainers.image.source"?: string;
    /** Version of the packaged software. The version MAY match a label or tag in the source code repository, may also be Semantic versioning-compatible */
    "org.opencontainers.image.version"?: string;
    /** Source control revision identifier for the packaged software. */
    "org.opencontainers.image.revision"?: string;
    /** Name of the distributing entity, organization or individual. */
    "org.opencontainers.image.vendor"?: string;
    /** License(s) under which contained software is distributed as an SPDX License Expression. */
    "org.opencontainers.image.licenses"?: string;
    /** Name of the reference for a target. */
    "org.opencontainers.image.ref.name"?: string;
    /** Human-readable title of the image */
    "org.opencontainers.image.title"?: string;
    /** Human-readable description of the software packaged in the image */
    "org.opencontainers.image.description"?: string;
}

/** Docker V2 image layer descriptor including config and layers. */
export declare interface OciDescriptor {
    /** Layer media type */
    mediaType: string;
    /** Layer size */
    size: number;
    /** Layer digest */
    digest: string;
    /** Specifies a list of URIs from which this object may be downloaded. */
    urls?: string[];
    /** Additional information provided through arbitrary metadata. */
    annotations?: OciAnnotations;
}

/**
 * Type representing an OCI image manifest (manifest of media type "application/vnd.oci.image.manifest.v1+json").
 * See the specification at https://github.com/opencontainers/image-spec/blob/main/manifest.md for more information.
 */
export declare type OciImageManifest = {
    /** Schema version */
    schemaVersion: 2;
    /** The media type, when used, must be application/vnd.oci.image.manifest.v1+json. */
    mediaType?: `${KnownManifestMediaType.OciImageManifest}`;
    /** When the manifest is used for an artifact, the type of said artifact. */
    artifactType?: string;
    /** V2 image config descriptor */
    config: OciDescriptor;
    /** List of V2 image layer information */
    layers: OciDescriptor[];
    /** Additional information provided through arbitrary metadata. */
    annotations?: OciAnnotations;
};

/**
 * `Artifact` is the general term for items stored in a container registry,
 * and can include Docker images or other Open Container Initiative (OCI) artifact types.
 *
 * The {@link RegistryArtifact} interface is a helper that groups information and operations about an image
 * or artifact in a container registry.
 *
 */
export declare interface RegistryArtifact {
    /**
     * The Azure Container Registry endpoint.
     */
    readonly registryEndpoint: string;
    /**
     * Repository name.
     */
    readonly repositoryName: string;
    /**
     * fully qualified reference of the artifact.
     */
    readonly fullyQualifiedReference: string;
    /**
     * Deletes this registry artifact by deleting its manifest.
     * @param options -
     */
    delete(options?: DeleteArtifactOptions): Promise<void>;
    /**
     * Deletes a tag. This removes the tag from the artifact and its manifest.
     * @param tag - the name of the tag to delete.
     * @param options -
     */
    deleteTag(tag: string, options?: DeleteTagOptions): Promise<void>;
    /**
     * Retrieves the properties of the manifest that uniquely identifies this artifact.
     * @param options -
     */
    getManifestProperties(options?: GetManifestPropertiesOptions): Promise<ArtifactManifestProperties>;
    /**
     * Updates the properties of the artifact's manifest.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const artifact = client.getArtifact(repositoryName, artifactTagOrDigest)
     * const updated = await artifact.updateManifestProperties({
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param options -
     */
    updateManifestProperties(options: UpdateManifestPropertiesOptions): Promise<ArtifactManifestProperties>;
    /**
     * Retrieves the properties of the specified tag.
     * @param tag - the tag to retrieve properties.
     * @param options -
     */
    getTagProperties(tag: string, options?: GetTagPropertiesOptions): Promise<ArtifactTagProperties>;
    /**
     * Updates the properties of a given tag.
     *
     * Example usage:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credential);
     * const artifact = client.getArtifact(repositoryName, artifactTagOrDigest)
     * const updated = await artifact.updateTagProperties(tag, {
     *   canDelete: false,
     *   canList: false,
     *   canRead: false,
     *   canWrite: false
     * });
     * ```
     * @param tag - name of the tag to update properties on
     * @param options -
     */
    updateTagProperties(tag: string, options: UpdateTagPropertiesOptions): Promise<ArtifactTagProperties>;
    /**
     * Returns an async iterable iterator to list the tags that uniquely identify this artifact and the properties of each.
     *
     * Example using `for-await-of` syntax:
     *
     * ```javascript
     * const client = new ContainerRegistryClient(url, credentials);
     * const repository = client.getRepository(repositoryName);
     * const artifact = repository.getArtifact(digest)
     * for await (const tag of artifact.listTagProperties()) {
     *   console.log("tag: ", tag);
     * }
     * ```
     *
     * Example using `iter.next()`:
     *
     * ```javascript
     * const iter = artifact.listTagProperties();
     * let item = await iter.next();
     * while (!item.done) {
     *   console.log("tag properties: ", item.value);
     *   item = await iter.next();
     * }
     * ```
     *
     * Example using `byPage()`:
     *
     * ```javascript
     * const pages = artifact.listTagProperties().byPage({ maxPageSize: 2 });
     * let page = await pages.next();
     * let i = 1;
     * while (!page.done) {
     *  if (page.value) {
     *    console.log(`-- page ${i++}`);
     *    for (const tagProperties of page.value) {
     *      console.log(`  repository name: ${tagProperties}`);
     *    }
     *  }
     *  page = await pages.next();
     * }
     * ```
     * @param options -
     */
    listTagProperties(options?: ListTagPropertiesOptions): PagedAsyncIterableIterator<ArtifactTagProperties>;
}

/**
 * Contains response data for the listRepositoryNames operation.
 */
export declare interface RepositoryPageResponse extends Array<string> {
    /**
     * Continuation token to pass to `byPage()` to resume listing of more results if available.
     */
    continuationToken?: string;
}

/**
 * Options for configuring the upload manifest operation.
 */
export declare interface SetManifestOptions extends OperationOptions {
    /**
     * Media type of the uploaded manifest
     */
    mediaType?: string;
    /**
     * Tag to give the uploaded manifest
     */
    tag?: string;
}

/**
 * The result from uploading a manifest to the registry.
 */
export declare interface SetManifestResult {
    /**
     * The digest of the uploaded manifest, calculated by the registry.
     */
    digest: string;
}

/**
 * Contains response data for the listTags operation.
 */
export declare interface TagPageResponse extends Array<ArtifactTagProperties> {
    /**
     * Continuation token to pass to `byPage()` to resume listing of more results if available.
     */
    continuationToken?: string;
}

/**
 * Options for the `updateManifestProperties` method of `RegistryArtifact`.
 */
export declare interface UpdateManifestPropertiesOptions extends OperationOptions {
    /** Whether or not this manifest can be deleted */
    canDelete?: boolean;
    /** Whether or not this manifest can be written to */
    canWrite?: boolean;
    /** Whether or not to include this manifest when listing manifest properties */
    canList?: boolean;
    /** Whether or not this manifest can be read */
    canRead?: boolean;
}

/**
 * Options for the `setProperties` method of `ContainerRepository`.
 */
export declare interface UpdateRepositoryPropertiesOptions extends OperationOptions {
    /** Whether or not this repository can be deleted */
    canDelete?: boolean;
    /** Whether or not this repository can be written to */
    canWrite?: boolean;
    /** Whether or not include this repository when listing repositories */
    canList?: boolean;
    /** Whether or not this repository can be read */
    canRead?: boolean;
}

/**
 * Options for the `updateTagProperties` method of `RegistryArtifact`.
 */
export declare interface UpdateTagPropertiesOptions extends OperationOptions {
    /** Whether or not this tag can be deleted */
    canDelete?: boolean;
    /** Whether or not this tag can be written to */
    canWrite?: boolean;
    /** Whether or not to include this tag when listing tags */
    canList?: boolean;
    /** Whether or not this tag can be read */
    canRead?: boolean;
}

/**
 * Options for configuring the upload blob operation.
 */
export declare interface UploadBlobOptions extends OperationOptions {
}

/**
 * The result from uploading a blob to the registry.
 */
export declare interface UploadBlobResult {
    /**
     * The digest of the uploaded blob.
     */
    digest: string;
    /**
     * The size of the uploaded blob in bytes.
     */
    sizeInBytes: number;
}

export { }
